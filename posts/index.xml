<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 識之箱庭</title><link>https://HoshikawaRyuukou.github.io/posts/</link><description>Recent content in Posts on 識之箱庭</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>HoshikawaRyuukou</copyright><lastBuildDate>Wed, 07 Jun 2023 22:11:00 +0000</lastBuildDate><atom:link href="https://HoshikawaRyuukou.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Test - NUnit</title><link>https://HoshikawaRyuukou.github.io/posts/test-nunit/</link><pubDate>Wed, 07 Jun 2023 22:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/test-nunit/</guid><description>Ref Doc NUnit 幾個參數化測試的方式</description></item><item><title>Test - Unit Test</title><link>https://HoshikawaRyuukou.github.io/posts/test-unit-test/</link><pubDate>Sun, 04 Jun 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/test-unit-test/</guid><description>以下觀點不一定適用於各專案，請因地制宜。
以反面例子來看單元測試 慢 不穩定 脆弱 不方便 問題出在不可控
希望是可控的 可重現一樣結果 以整體專案的角度來看單元測試 專案內分為 不可控 與 可控 兩部分
不可控: 檔案/資料庫/第三方套件 可控: 除不可控以外自己所寫的部分 可控內分為 不可測 與 可測 兩部分
不可測: 與不可控接觸的部分，因此會希望這部分越單純越好。 可測: 為專案內價值較高，須小心維護的部分。 目標: 可測範圍盡量大，不可測盡量小。
FAQ 單元測試相較於手動測試的優勢 ? 可以輕鬆的跑完多個 Test Cases Static 要不要測 ? 直接使用真實行為 透過測試框架強測 重構/隔離/依賴注入 Ref 一起設計出可被單元測試的程式碼吧！ [Day 2]Unit Testing 簡介 .NET Core 和 .NET Standard 的單元測試最佳做法</description></item><item><title>Test - 概述</title><link>https://HoshikawaRyuukou.github.io/posts/test-%E6%A6%82%E8%BF%B0/</link><pubDate>Sat, 03 Jun 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/test-%E6%A6%82%E8%BF%B0/</guid><description>以下觀點不一定適用於各專案，請因地制宜。
在開始寫 code 之前 測試文化: 底下的人願意寫，上面的人願意給時間。 測試的順位: 從商業價值最高的功能開始。 較低的測試價值 需求尚未明朗又必須交付成果。 取決於經營者對價值的認定，其實跟程式沒多大關係。 不是所有的程式都可以測試，有時候為了測試，程式需要先重構成可以測試的樣子。 Ref 一次搞懂單元測試、整合測試、端對端測試之間的差異</description></item><item><title>Unity - Package - xLua</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-xlua/</link><pubDate>Sun, 28 May 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-xlua/</guid><description>本次操作 xLua 主要是做熱更方案的評估測試，筆者目前還是偏好使用 HybridCLR。
Official Tencent/xLua 評估 使用 lua 仍是目前主流/穩定做法 (畢竟也行之有年了)。 邏輯操作可能要移師到 lua 側。 缺少 ide 支援如果要在 lua 側 進行 unity 相關操作時，維護/除錯成本極高。 Example 在 lua 側進行 unity 相關操作
local speed = 10 local lightCpnt = nil function start() print(&amp;#34;lua start...&amp;#34;) print(&amp;#34;injected object&amp;#34;, lightObject) lightCpnt= lightObject:GetComponent(typeof(CS.UnityEngine.Light)) end function update() local r = CS.UnityEngine.Vector3.up * CS.UnityEngine.Time.deltaTime * speed self.transform:Rotate(r) lightCpnt.color = CS.UnityEngine.Color(CS.UnityEngine.Mathf.Sin(CS.UnityEngine.Time.time) / 2 + 0.5, 0, 0, 1) end function ondestroy() print(&amp;#34;lua destroy&amp;#34;) end</description></item><item><title>Unity - Editor - ScriptedImporter</title><link>https://HoshikawaRyuukou.github.io/posts/unity-editor-scriptedimporter/</link><pubDate>Sat, 27 May 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-editor-scriptedimporter/</guid><description>用途 使用C# 為Unity 本身不支持的文件格式編寫自定義資源導入器，從而添加支持。 注意 Scripted Importer 無法處理已由 Unity 本身處理的文件擴展名。 Example 這裡將 .lua 以 TextAsset
using UnityEngine; using System.IO; using UnityEditor.AssetImporters; [ScriptedImporter( 1, &amp;#34;lua&amp;#34; )] public class LuaImporter : ScriptedImporter { public override void OnImportAsset( AssetImportContext ctx ) { TextAsset subAsset = new TextAsset( File.ReadAllText( ctx.assetPath ) ); ctx.AddObjectToAsset( &amp;#34;text&amp;#34;, subAsset ); ctx.SetMainObject( subAsset ); } } Ref Scripted Importers [Unity] 资源工作流程 - ScriptedImporter</description></item><item><title>通用設計 - Inversion of Control (IoC) 與 Dependency Injection (DI)</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-inversion-of-control-ioc-%E8%88%87-dependency-injection-di/</link><pubDate>Fri, 05 May 2023 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-inversion-of-control-ioc-%E8%88%87-dependency-injection-di/</guid><description>控制反轉 Inversion of Control，以下皆簡稱 IoC。 依賴注入 Dependency Injection，以下皆簡稱 DI。
之前還有提到過 依賴倒置原則 (Dependency Inversion Principle，DIP)，而筆者理解到這三者的關係是
DI 是 IoC 的一種實踐方式 DIP 則能為 IoC 提高依賴穩定性 為什麼需要 資源複用: 避免創建重複對象，有些對象只需要實例化一個就夠了，不需要使用方都自己 new 一個新的。
集中配置依賴項: 依賴需求方操作其依賴項來完成任務才是他主要的責任，如果還要處理依賴項的實例化(更不用說依賴項的依賴項要怎麼處理)，責任就模糊了，因此將依賴項的創建和配置的控制權交給 IoC Container。
基本操作 通常而 IoC Container 包含以下操作：
Register：註冊類型和依賴關係 Resolve：創建並註入依賴關係 Dispose：管理生命週期 而實踐方式常見的有兩種
Service Locator 服務定位器 可以簡單理解為直接使用容器本身，因此依賴需求方在需要依賴的地方可以使用 Locator.Resolve 來取得依賴，但這樣有幾個問題
Resolve 可以填什麼 ? 是不是有註冊的項目都能任意取得阿 ? 這也是有些人認為服務定位器有反模式味道的點 DI 依賴注入 依賴注入則是間接地使用容器，常透過三種方式注入依賴項，
建構子(推薦) 屬性 方法 權限相對清晰(建構子注入)，能用依賴項的都在建構子給你了，不過你要額外new 其他東西也是沒人攔得住。此外依賴需求方是不知道容器的存在(理想狀態，但有時會需要一些注入標記)</description></item><item><title>Unity - Package Manager</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-manager/</link><pubDate>Sat, 22 Apr 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-manager/</guid><description>Package Samples 對應有些模組的操作比較複雜繁瑣，有時需要有一些 Sample 做參考。官方 Package Manager 有個 &amp;ldquo;半套&amp;rdquo; Sample 工作流，讓人不是很舒服。
官方文件
Sample 資料夾後面加了波浪號 (~) 告訴 Unity 忽略 Samples~ 文件夾中的內容，此類文件夾不使用.meta文件進行跟踪。忽略 Samples~ 對 Package 使用者是好的，畢竟不是每個人都需要。
但對 Package 開發者，畢竟 Samples 也是要進版控的，而這樣改名的作法會徒增一些重命名的提交也有點煩躁(除非在修改 Sample 的過程中完全不提交)。原先想說寫個 Samples ↔ Samples~ 切換的腳本就好，會一直有 meta 檔的警告(刪掉/改名都還是在)。
官方作法 論壇中的某篇討論才記載他們的做法(倒是加到文件中阿&amp;hellip;)
在內部確實使用了名為 Samples 的文件夾 (沒有 Samples~ ) 在推送新包版本之前通過腳本對其進行重命名(透過 CI ) OpenUPM 的作者也是使用類似的工作流，總之筆者也調整為上述的方式。
透過 GitHub Actions Workflow 調整目錄名 筆者不熟 GitHub Actions/ YAML/ 文件操作，但這種初階的操作就交由 chatgpt 代勞，幫我省去不少實驗成本。這裡的操作只是堪用，應該有更好的方式。
以下是筆者要求的條件
想透過 GitHub Actions 中的 workflow 完成 如果 forPackage 分支已存在則將其刪除 從 main 建立新的 forPackage 分支 Assets/Modules 的所有子目錄(同時有 &amp;ldquo;package.</description></item><item><title>Unity - Package - HybridCLR</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-hybridclr/</link><pubDate>Tue, 11 Apr 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-hybridclr/</guid><description>以下將著重在&amp;quot;程式碼&amp;quot;的熱更。
簡述 HybridCLR 的 github 星數已經超過 ILRuntime 了，且中國那邊的主流框架幾乎都對其加入支援，是備受期待的存在。
其極大簡化過往麻煩且效率不彰的熱更流程。現在主流的方式有兩個：Lua 和 ILRuntime。但主流並不一定是好用的，也有可能只是迫不得已。主流兩者在筆者看來最難受的事是「侵入性」極強，有時為了熱更必須將業務邏輯移到 Lua 和 ILRuntime，搞得綁手綁腳。大家也都抱怨很久了，但也沒有其他可靠方案，直到 HybridCLR 出現。
其最讓人驚豔的地方在於，過往的開發流幾乎不用更動(不用寫 Lua 到處黏來黏去，只要寫好 C# 即可)，僅在打包時調整一下工作流即可。
3.0 版本後流程優化得更順暢了，照著 快速上手可以很快地感受到其優點。
此外 Unity 引擎開發團隊宣布，他們已開始將 Unity 引擎運行時從 Mono 遷移到 .NET CoreCLR。他們還會提供融合 JIT 和 AOT 的解決方案，Unity 團隊計劃在 2024 年發布新編輯器。(雖然常跳票就是了)，因此筆者相信 類 HybridCLR 的作法在未來會成為主流做法，姑且先樂觀其成。
Official focus-creative-games/hybridclr focus-creative-games/hybridclr_trial focus-creative-games/hybridclr_unity HybridCLR c#热更新 實測 為此筆者以一個小專案測試
App Module 主模組，非熱更模組(包含AOT) Navigation Module 熱更模組(應用程式是可以接受動態導航的) RockPaperScissors Module 熱更模組(一個簡單的猜拳應用) 模組之間的關係
App 啟動後會去下載 Navigation Module (一開始是沒有在本地) Navigation 有一組 UI 與下載 RockPaperScissors Module(也沒有在本地) 的邏輯段 測試結果 PC 與 Android 都可以完成動態加載邏輯與資源，且完全使用 C# 並以極低侵入完成熱更。在實作過程中反覆查了多次文件，確實需要一點成本來理解，但工作流(一次性)成型後便很舒服了。</description></item><item><title>AI - Stable Diffusion 實務應用</title><link>https://HoshikawaRyuukou.github.io/posts/ai-stable-diffusion-%E5%AF%A6%E5%8B%99%E6%87%89%E7%94%A8/</link><pubDate>Mon, 10 Apr 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/ai-stable-diffusion-%E5%AF%A6%E5%8B%99%E6%87%89%E7%94%A8/</guid><description> How to Make Game Asset with AI - Stable Diffusion Tutorial 使用AI製作遊戲用資源 How to Make 3D Game Assets with AI (Free and Easy) - Stable Diffusion + Blender Tutorial 2022 AI AVG製作紀錄 試用ControlNet 1.1製作頭像與立繪 Stable Diffusion AI協作 +PS 工作紀錄1 -登入圖 WorkFlow Stable Diffusion+PS - Avatar Remake WorkFlow / Stable Diffusion 協作 +PS 工作紀錄2 - 頭圖復刻 Stable Diffusion + Blender 2DTopGame architecture WorkFlow/ Stable Diffusion AI +Blender 繪製2D遊戲建築 【Stable diffusion小教程】运用AI实现 草图→清稿→上色→3d效果全流程 仿草圖 lora训练/stable diffusion/AI模仿人类画草图 放大算法 解决图片模糊！4这种不同方法实现AI高清放大【Stable diffusion小教程】</description></item><item><title>AI - Stable Diffusion 進階 ControlNet</title><link>https://HoshikawaRyuukou.github.io/posts/ai-stable-diffusion-%E9%80%B2%E9%9A%8E-controlnet/</link><pubDate>Mon, 10 Apr 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/ai-stable-diffusion-%E9%80%B2%E9%9A%8E-controlnet/</guid><description>Version ControlNet1.1版更新了什麼增強了什麼?局部重繪大躍進!!新功能新介面介紹!! 姿勢 AI繪圖技術大突破，自由指定人物姿勢 AI會畫手指了!輕鬆畫出指定手指姿勢，讓AI繪圖成功率大增 AI繪圖免費3D骨架工具，讓女神擺出你想要的姿勢，手指所有關節都可調整 stable diffusion 生成手有问题怎么办？ControlNet Depth Libra 精準度 Controlnet 新功能Reference Only，实现人设统一！ 「AIは同じキャラが出せない」はおしまい！新機能Reference-onlyなら学習なしでも画像だけで差分作成からアイコラも出来ちゃうぞ！！</description></item><item><title>AI - Stable Diffusion 進階 Extension</title><link>https://HoshikawaRyuukou.github.io/posts/ai-stable-diffusion-%E9%80%B2%E9%9A%8E-extension/</link><pubDate>Mon, 10 Apr 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/ai-stable-diffusion-%E9%80%B2%E9%9A%8E-extension/</guid><description>Prompt AI新插件改善tag污染：cutoff Stable Diffusion web UI x Cutoff：限制某些提詞的影響範圍，以顏色提詞做舉例 Lora 【AI绘画】LoRA进阶用法：分层控制 你真的会用LORA吗？超详细讲解LORA分层控制 LyCORIS Stable Diffusion web UI x a1111-sd-webui-lycoris：使用 LyCORIS 模型 AI 生成影像！ 修圖 [AI教程]stable diffusion 換臉修復崩臉的神器 face editor</description></item><item><title>AI - 雜記</title><link>https://HoshikawaRyuukou.github.io/posts/ai-%E9%9B%9C%E8%A8%98/</link><pubDate>Mon, 10 Apr 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/ai-%E9%9B%9C%E8%A8%98/</guid><description> 2023 Generative AI（AIGC 詠唱者年會）活動筆記</description></item><item><title>AI - Stable Diffusion 基本</title><link>https://HoshikawaRyuukou.github.io/posts/ai-stable-diffusion-%E5%9F%BA%E6%9C%AC/</link><pubDate>Fri, 10 Mar 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/ai-stable-diffusion-%E5%9F%BA%E6%9C%AC/</guid><description>安裝 圖像任你生！自建 Stable Diffusion WebUI 圖像生成平台 AI繪圖：Windows安裝Stable Diffusion WebUI教學 基本知識 Features 【AI绘图】入门必看，一次弄懂所有技术名词 頻道 萌芽綜合天地 - Stable Diffusion web UI 人工治障 杰克艾米立 咖啡猫CuteCat 大江户战士 週刊 MiSiMO 社群 Civitai AI 그림 채널 畫廊 (NSWF) Prompt Search chichi-pui Prompt 注意 Prompt 的效果很大程度取決於使用的 checkpoint (部分 Prompt 會無效)
索引 AI繪圖魔導書 NovelAI魔咒小课堂 NovelAI tag生成器 V2.1 【Stable Diffusion】プロンプト（呪文）ガイド 主題 AIツール関係 Color Diffusion 形容顏色深淺，可以不只用dark或light</description></item><item><title>AI - ChatGPT 初探</title><link>https://HoshikawaRyuukou.github.io/posts/ai-chatgpt-%E5%88%9D%E6%8E%A2/</link><pubDate>Wed, 01 Mar 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/ai-chatgpt-%E5%88%9D%E6%8E%A2/</guid><description>相關背景 ChatGPT (可能)是怎麼煉成的 - GPT 社會化的過程 【生成式AI】ChatGPT 原理剖析 (1/3) — 對 ChatGPT 的常見誤解 目的 我主要測試兩個方向
寫 程式 能力: 寫程式能力是因為與我工作有關係，反正遲早要來的，早點試試看。 寫 小說 能力: ChatGPT 的本質是文字接龍，因此測一下最純粹的應用。 寫 程式 能力 因為 ChatGPT 是基於舊訊息，所以我選了一個經典的遊戲 &amp;ldquo;貪食蛇&amp;rdquo;，我預計他寫得出來，也確實寫出來。
我希望他以 Clean Architecture 改寫，我預計他寫不出來，但寫出來了(必須說有點嚇到)。大概閱了一下，應該沒有太大問題，不過 Code 基本都會因太長而斷掉，有點麻煩。(圖片只有一部分因為很長)
另外試了一下寶可夢對戰，先詢問使否知道，然後請他以 C# 實作。 拿來做為 Prototype 似乎還行，雖然很多都是寫死的。基本上適當的引導，可以做得更好(先定義屬性/能力/道具&amp;hellip;)，這將是一門新學問。
寫 小說 能力 他的不可預測性對我這種很能靈光一閃的人來說幫助很大，給幾個設定他就開始亂掰(當然可以多設一些限制)。
幾個缺點
會忘設定，因此有時要一直提醒。 上下文連貫，是優點也是缺點? 因為一旦被汙染就沒辦法剃除。只能開一個新的。 強制清新/健康/正能量，常常在末段應轉方向&amp;hellip; Content Policy 首先正常的答案會偏向清新/健康/正能量，會規避負面生成。不過就我查到的資訊來看，檢查機制與生成機制似乎是分開的。此外你不能要求他提供為何會觸發 content policy (小機率可以)
上述的問題哪裡違反 content policy，他會叫你去問 ChatGPT 團隊。 但注意上下文中一旦出現 content policy，很可能導致接下來會越難成功。
ChatGPT 100% 是讀過OO小說的，是寫得出來得。但現在越來越嚴格，需要旁敲側擊。至少使用者的問題不會觸發，以下是我的經驗，成功與否因素很多
前置動作要先聲明 ChatGPT 是小說家在開始</description></item><item><title>Unity - WorkFlow - Build &amp; Publish</title><link>https://HoshikawaRyuukou.github.io/posts/unity-workflow-build-publish/</link><pubDate>Mon, 27 Feb 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-workflow-build-publish/</guid><description>Build repositories.cfg could not be loaded. Unable to find player assembly: XXXX\Temp\StagingArea\Data\Managed\UnityEngine.TestRunner.dll Device Quickly preview your game on Android device | Unity tutorial Publish Privacy policy for your game? No problem! (generate and publish) Publish your UNITY game on Google Play Store - 2023 guide</description></item><item><title>Hugo - 筆記</title><link>https://HoshikawaRyuukou.github.io/posts/hugo-%E7%AD%86%E8%A8%98/</link><pubDate>Sat, 25 Feb 2023 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/hugo-%E7%AD%86%E8%A8%98/</guid><description> Rendering Images in Markdown Preview of Hugo Site mklink /D images .\static\images</description></item><item><title>架構設計 - Modularization</title><link>https://HoshikawaRyuukou.github.io/posts/%E6%9E%B6%E6%A7%8B%E8%A8%AD%E8%A8%88-clean-architecture-and-modularization/</link><pubDate>Wed, 22 Feb 2023 21:21:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E6%9E%B6%E6%A7%8B%E8%A8%AD%E8%A8%88-clean-architecture-and-modularization/</guid><description>前述 首先幾篇文章是基於 Clean Architecture 的基礎，建議先閱讀以下連結已具備基礎知識
The missing chapter CA 原著 Chapter 34 - The missing chapter - Actual implementation details of an architecture 連結 34章摘要心得，請先觀看裡面的圖表(重要) CA Modularization Multiple ways of defining Clean Architecture layers Package by Component with Clean Modules in Java Package by feature or component Vertical Slice Slices vs. Layers Restructuring to a Vertical Slice Architecture Vertical Slice Architecture, not Layers! Modular Monolith Majestic Modular Monoliths (強烈建議) Modular Monolith architecture (強烈建議讀完這個系列) 各 Package 策略的圖請參考上方連結 34 章摘要心得</description></item><item><title>Unity - Sites</title><link>https://HoshikawaRyuukou.github.io/posts/unity-sites/</link><pubDate>Mon, 20 Feb 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-sites/</guid><description>Blog 游戏石匠Super L&amp;rsquo;s Blog コガネブログ 渋谷ほととぎす通信 きゅぶろぐ LIGHT11 Raspberlyのブログ PG日誌 やらなイカ？ Game Dev Beginner - Everyone Can Make Games LianBai (:3[kanのメモ帳] Learning Unity Learning Materials</description></item><item><title>Unity - 基礎</title><link>https://HoshikawaRyuukou.github.io/posts/unity-%E5%9F%BA%E7%A4%8E/</link><pubDate>Mon, 20 Feb 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-%E5%9F%BA%E7%A4%8E/</guid><description>Analysis Unity Optimize Your Game Using Profiler Unity 手機遊戲最佳化雜談– 內建Profiling Animation Introduction to 3D Animation Systems Audio Unity Audio Clip Import Settings For The Best Performance Audio tutorial for Unity: the Audio Mixer The right way to make a volume slider in Unity Build repositories.cfg could not be loaded. unity Camera Understanding Orthographic Size 探寻 Unity Camera 属性之 Clear Flags Unityの画面のアスペクト比と解像度を自動変換　全スマホ・複数解像度に対応させる Editor 在unity编辑器不同位置添加菜单 SerializeReferenceをつけている型をリネーム・削除する時の注意点 What are EditorBuildSettings config objects used for or how can I use them?</description></item><item><title>架構設計 - Clean Architecture</title><link>https://HoshikawaRyuukou.github.io/posts/%E6%9E%B6%E6%A7%8B%E8%A8%AD%E8%A8%88-clean-architecture/</link><pubDate>Sat, 04 Feb 2023 20:03:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E6%9E%B6%E6%A7%8B%E8%A8%AD%E8%A8%88-clean-architecture/</guid><description>以下 Clean Architecture 簡稱 CA
這裡還是先引用 Uncle Bob 的分層圖 The Clean Code Blog - The Clean Architecture 筆者認爲可擴展性是系統架構的重要考量。畢竟應用程式會演化，必須不斷更新與修改系統以滿足新的需求，而 CA 是其中一種實現方針。筆者在這裡不會寫出詳細的介紹，想了解的可以參考 Ref 整理的連結或是 CA 相關書籍。
本文著重於促使筆者思考方式改變的幾個重要觀念。
依賴關係 相依性: 向內圈依賴，且盡量避免跨層依賴 (有些例外之後說明)。 Dependency Inversion Principle (DIP): 內圈定義介面，外圈實作。 基於這兩個規則所帶來的是
單向依賴流 : 紊亂的依賴流可能造成牽一髮動全身的窘境。尤其是當 Domain 去依賴到細節時。 延後實作 : UseCase/Adapter 都是依賴於應用層所開出的介面。因此業務/畫面能獨立開發，不用互相等待(理想狀態)。 而筆者在實作時的基本型架構通常如下圖(比較接近 CA 書中的另外一張圖，我這裡做了簡化)，Adapter 只分成 Input/Output Port。 Domain: 領域邏輯 UseCase: 應用邏輯 Domain + UseCase: 業務邏輯 InputPort: 用例功能使用方介面 OutputPort: 用例功能支援方介面 Adapter: 將外部與用例功能接合的膠水代碼 不過架構會針對不同情況做調整，細節參考另一篇文章
架構設計 - Clean Architecture and Modularization</description></item><item><title>通用設計 - Guard Clauses</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-guard-clauses/</link><pubDate>Tue, 10 Jan 2023 21:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-guard-clauses/</guid><description>目的 符合 Fail Fast 的原則，驗證條件並在不滿足條件時立即停止執行。 增加可讀性(更扁平)，減少了巢狀判斷。 例子請參考 Guard Clause Extra - Guard Class 將通用的保護子句封裝在一個專門的類是一種很好的做法，可重用邏輯並編寫更具可讀性的保護子句。
可參考這個庫 GuardClauses Extra - Value Object Stop using trivial Guard Clauses! Try this instead
文章作者避免瑣碎 Guard 的方式，是使用 Value Object，來避免域接受到無效參數。這個作法在筆者看來才是真正意義上的 Fail Fast。(YT評論區也建議閱讀，有許多不錯的討論)
但不可否認的 Guard Clause 作法在大多情況下是有益的。
Ref Guard Clause Implementation Patterns: Guard Clause GuardClauses Stop using trivial Guard Clauses! Try this instead</description></item><item><title>C# - 筆記</title><link>https://HoshikawaRyuukou.github.io/posts/c#-%E7%AD%86%E8%A8%98/</link><pubDate>Thu, 05 Jan 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/c#-%E7%AD%86%E8%A8%98/</guid><description>語法 捨棄 - C# 基本概念 C#中 ??、 ?、 ?: 、?.、? 问号 Type C# 4.0：Covariance 與 Contravariance 觀念入門 Data Different ways to return data in C# ValueTuple ValueTuple 是 value type，所以它使用的記憶體空間使用在 program stack，因此使用不會有 garbage collection
Format 內插字串 Collection C# 回傳內部資料集合的幾種方式，考慮封裝與設計需求 Iterate over two collections of equal length foreach (var (cell, id) in cells.Zip(randomizedIDs, (key, value) =&amp;gt; (Cell: key, ID: value))) { idDict[cell] = id; cell.selectCallback = Select; } Utils Random var random_list = list.</description></item><item><title>通用設計 - 設計原則</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87/</link><pubDate>Mon, 02 Jan 2023 21:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87/</guid><description>Library DevIQ Experiences Advice for junior developers Other The Last Responsible Moment DRY is about Knowledge</description></item><item><title>軟體設計 - Domain-Driven Design 初探</title><link>https://HoshikawaRyuukou.github.io/posts/%E8%BB%9F%E9%AB%94%E8%A8%AD%E8%A8%88-domain-driven-design-%E5%88%9D%E6%8E%A2/</link><pubDate>Thu, 15 Dec 2022 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E8%BB%9F%E9%AB%94%E8%A8%AD%E8%A8%88-domain-driven-design-%E5%88%9D%E6%8E%A2/</guid><description>必須先聲明筆者仍在學習中，以下屬個人觀點
動機 筆者發現在使用 Clean Architecture (CA) 時越來越力不從心，因此開始研究 Domain-Driven Design (DDD)，事出有因，列出幾點問題與對應方式。
重複的程式碼 主因是 貧血域模型 (Anemic Domain Model)，表示模型中幾乎只有 Get/Set，這導致了 Domain層 (業務邏輯) 滲透到 Application層 (應用邏輯)，某些對 Domain 的操作重複出現在多個的 Usecase (應用邏輯)。 重新分析系統，區分出不同上下文，設計充血域模型，將業務邏輯設計進去。 域模型的一致性問題 Domain 面對四面八方的操作，顯得很亂且充滿不確定(會不會模型之間的關係因為更改而被破壞) 引入聚合(Aggregate)來維持保護邊界內的不變條件。 Primitive Obsession 這會造成對模型的不信任，進而寫出一些防禦性程式設計。 引入值物件(Value Object)來確保不變性與自我驗證(即不正確就不應該存在)。 以上這幾點是筆者比較有感的。
概述與想法 Domain-Driven Design (DDD)，出自 Eric Evans 2003 年出版的一本書，以領域模型為中心來進行系統的分析設計。不是架構也不是技術，是一種方法論，可以搭配不同類型的架構來實現
Layered Architecture Hexagonal Architecture Clean Architecture (以下稱 CA ) Command Query Responsibility Segregation (CQRS) 原著中是使用 Layered Architecture 的架構作為示範，但該章的重點是在隔離 Domain，在 Google 的時候有所謂 &amp;ldquo;DDD 架構圖&amp;rdquo;，但筆者覺得不太精確，因為 DDD 主要的發力點是在 Domain，應該稱作 &amp;ldquo;OO架構以DDD實作Domain&amp;rdquo; 會比較合適。</description></item><item><title>通用設計 - Data Transfer Object (DTO)</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-data-transfer-object-dto/</link><pubDate>Sun, 11 Dec 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-data-transfer-object-dto/</guid><description>什麼是 DTO？ Data Transfer Object (數據傳輸對象) 是定義如何在應用程序之間發送數據的對象。它僅用於發送和接收數據，本身不包含任何邏輯。
為什麼使用 DTO？ 輕鬆收發 在沒有任何邏輯的基礎上，可以僅使用序列化與反序列化就保證對象的完整性和可傳遞性。
避免過度暴露訊息 對分層或模組來說，彼此間應盡量降低耦合。下圖以公園廁所報修為案例。
這個資料流由鄉公所傳到基層人員手上，中間經過兩個邊界
鄉公所 | 工程公司 =&amp;gt; DTO (公文) 工程公司 | 基層人員 =&amp;gt; DTO (簡訊) 每個單位的關注點不同，在意的資料也會不同，DTO 做為邊界兩方做最小程度的媒介，隱藏的不該被關注(敏感)的事
印章對工程公司並不是必要資訊 詳細的時間格式是對基層人員並不是必要資訊 在實作上常被用於轉換 DomainModol -&amp;gt; DomainDto
注意事項 類別數量增加，請自行評估使用情形
Ref Cutting Edge - Pros and Cons of Data Transfer Objects The DTO (Data Transfer Object) Data Transfer Objects Clean Architecture : why not using the entity as request model of the use case (interactor) Difference between Entity and DTO</description></item><item><title>通用設計 - 邏輯與畫面分離 MVP 與 MVVM</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-%E9%82%8F%E8%BC%AF%E8%88%87%E7%95%AB%E9%9D%A2%E5%88%86%E9%9B%A2-mvp-%E8%88%87-mvvm/</link><pubDate>Sat, 10 Dec 2022 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-%E9%82%8F%E8%BC%AF%E8%88%87%E7%95%AB%E9%9D%A2%E5%88%86%E9%9B%A2-mvp-%E8%88%87-mvvm/</guid><description>導覽 網上已經有很多不錯的文章，再寫一份類似的整理文章意義也不大，對 MVP / MVVM 感到陌生，不妨閱讀以下連結，會幫助你理解 MV系列 的發展。因此這裡只是提出一些重點觀念與實作考量。
界面之下：还原真实的MV*模式 正确认识 MVC/MVP/MVVM 站在思想层面看MVX架构 MVP Pattern: Part 2 Supervising Controller Part 2 — Converting Presenters into ViewModels 前述 眾所周知畫面(View)的變更需求是很高的，因此會希望業務與畫面分離，以實現關注點分離（Separation of Concerns，SoC）。但分開的事務之間仍需溝通，因此需要有單位出來做協調，MVP 與 MVVM 兩者以不同方式來實作。
MVP: Model-View-Presenter MVVM: Model-View-ViewModel *Model 指的是業務邏輯可能是 DomainModel/ Usecase/ Service 等，依系統的規模架構而定。
以下是筆者常使用 3 種類型的依賴關係 MVP (DIP) Presenter 基於 依賴倒置原則 定義 IView 介面來讓 View 實作。 Presenter 可適用於不同的 View(IView)。 View 被綁訂於定義出 IView 的 Presenter。 View 一般設計成 Passive View。 MVP Presenter 基於 轉接器模式(Adapter Pattern) 作為膠水代碼以協調 Model 與 View。 Presenter 是配合 View 的那一方，畢竟在前端 View 組件是有一定的重用考量(也就是 View 不能改)。 基於實作上的經驗，View 更換的次數沒有想像中的高。所以這個方案是筆者比較常用的(實作最快)，當真的有變化時在往 MVP (DIP) 或 MVVM 調整即可。 MVVM 與上述 MVPs 最大的不同是 ViewModel 對 View 一無所知，僅是公開狀態/數據流供外部觀察，完全隔離了畫面，純粹管理狀態。 ViewModel 基於 觀察者模式(Observer Pattern)，所以一個 ViewModel 可被多個 View 觀察。 View 只需要訂閱該狀態並反映它。Data Binding 可簡化綁定動作。 筆者覺得 ViewModel 的難點在於其大小，太大很能管控，太小又會導致狀態很分散。十分依賴規劃者的經驗。</description></item><item><title>Assets - 素材</title><link>https://HoshikawaRyuukou.github.io/posts/assets-%E7%B4%A0%E6%9D%90/</link><pubDate>Tue, 22 Nov 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/assets-%E7%B4%A0%E6%9D%90/</guid><description>Color Coolors Palettable Icon ICOOON MONO iconmonstr Flaticon IconKitchen Feature Graphics Google Play Feature Graphics Font 中文免費字體 Google Fonts Audio 魔王魂 効果音ラボ Image Unsplash Image API | Free HD Photo API Lorem Picsum Photosku Textures Poly Haven 背景 OKUMONO Misc Opengameart Kenney かわいいフリー素材集 いらすとや Info 網路資源列表| DeTools</description></item><item><title>通用設計 - Navigation</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-navigation/</link><pubDate>Wed, 16 Nov 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-navigation/</guid><description>以下 Feature 指的是一個功能獨立的模組，Feature A 將簡稱 A。
問題 應用程式中有一個由 A 到 B 的導航，那這個導航是誰的責任?
以下先討論 2 種狀況。
A 直接依賴 B 簡單粗暴的強耦合破壞了 A 的獨立性。當流程發生變化時，可能需要到各個 Feature 去修改。
Feature A -&amp;gt; Feature B A 引入導航器間接依賴 B 這作法將導航操作收斂到某個類中，但 A 仍然隱含的知道 B，這同樣破壞了 A 的獨立性。
Feature A -&amp;gt; INavigator.Route(View.FeatureB) // Enum or Feature A -&amp;gt; INavigator.Route(&amp;#34;FeatureB&amp;#34;) // 魔術字串 or Feature A -&amp;gt; INavigator.RouteFeatureB() 重新思考導航這件事
Feature 應該知道自己是能夠 被導航 或是 能導航到哪 嗎? 到底 A 能導航到 B 這件事是誰決定的? 應該隱約地感覺到了吧，導航並不屬於 A 也不屬於 B，導航是一個獨立操作，需要一個額外的單位來負責。此外這個單位多是屬於 App 級別的(因為該層級有對其他模組的正當訪問性，畢竟是負責做統合的)。</description></item><item><title>通用設計 - Dependency Inversion Principle (DIP)</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-dependency-inversion-principle-dip/</link><pubDate>Tue, 15 Nov 2022 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-dependency-inversion-principle-dip/</guid><description>依賴倒置原則 Dependency Inversion Principle，以下皆簡稱 DIP。
為什麼需要 先來看定義
高層次的模塊不應該依賴於低層次的模塊，兩者都應該依賴於抽象接口 抽象接口不應該依賴於具體實現。而具體實現則應該依賴於抽象接口 文謅謅的，但重點似乎是抽象。不如直接看個狀況劇:
有一個 Project A 需要使用播廣告的功能。分別採 2 個做法
直接依賴 直覺的做法。Project A 直接依賴於廣告模組(UnityAds)，這裡模組 Project A 被迫去了解 UnityAds 的實作細節(怎麼初始化/下載廣告/播廣告)。
目前沒甚麼問題，運作得很好&amp;hellip; 但很快問題就來了。UnityAds 因為某些原因不能用了! (假設後臺被打了什麼的)。於是找了另一個廣告模組(AdMob)，想要如法炮製，但有幾點可能會不好受。
要改的地方很分散 (廣告被 Project A 多處使用) Project A 需要處理不同的 API格式 (了解細節，單例、Callback、事件&amp;hellip;) 導致原先依賴 UnityAds 的模組需要重新編譯 (造成浪費時間) 原因是直接依賴外部模組導致的，相對於你的系統 UnityAds 是個外人，是不穩定的，去依賴一個不穩定的東西，也會導致自己變得不穩定。
依賴倒置 仔細想一下，Project A 直接依賴 UnityAds 是必要的嗎? 需求是播 UnityAds 的廣告? 還是播廣告? 為了實現穩定廣告服務的依賴源，我們將其抽象化
public interface IAdService { void Initialize(); void Load(); void Show(); } 但 UnityAds 與 AdMob 又不能直接實作這個介面怎麼辦，可以用配接器模式(Adapter Pattern)寫個轉接頭，想辦法讓外部細節符合 IAdService 的需求。現在需要廣告服務的部分均透過 IAdService來操作，不需再知道外部廣告模組的細節。</description></item><item><title>Unity - Packages</title><link>https://HoshikawaRyuukou.github.io/posts/unity-packages/</link><pubDate>Sat, 12 Nov 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-packages/</guid><description>Package Manager Installing Packages using UPM Package manager -&amp;gt; Advanced project settings Add Scoped Registries Name: package.openupm.com URL: https://package.openupm.com Scope(s): com.cysharp.unitask Package manager -&amp;gt; Packages: My Registries -&amp;gt; Install Unity中 .asmdef文件的作用 使用OpenUPM发布自己的Unity项目 开发Unity PackageManager 插件包 Creating Custom Packages for Unity 2018.3 How to remodel your project for asmdef and UPM Animation DOTween Link Async UniTask openupm - com.cysharp.unitask Patterns &amp;amp; Practices for efficiently handling C# async/await cancel processing and timeouts 精选Unity-Github开源库分享 最完美的异步操作解决方案 UniTask C# Task 指南 async/await,disposableを使って素直で読みやすいコードを書く UniTaskCompletionSource Should Support CancellationToken Debug UnityIngameDebugConsole Dependency Injection VContainer openupm - jp.</description></item><item><title>網路設計 - RPC</title><link>https://HoshikawaRyuukou.github.io/posts/%E7%B6%B2%E8%B7%AF%E8%A8%AD%E8%A8%88-rpc/</link><pubDate>Mon, 07 Nov 2022 21:06:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E7%B6%B2%E8%B7%AF%E8%A8%AD%E8%A8%88-rpc/</guid><description>RPC (Remote Procedure Call，遠端程序呼叫) 是一種通信協定，多用於分佈式系統的通信。
目的 讓客戶端呼叫遠程函式就像呼叫本地函式一樣。將網路通信封裝成函式來使用，那麼客戶端將不需要關心網路協定/模型。
流程 client 客戶端通過本地呼叫的方式呼叫服務 client stub 接收到請求後將參數序列化成能夠進行網路傳輸的訊息體 client stub 找到服務地址，並將訊息發送給服務端 server stub 收到訊息後進行反序列化 server stub 根據反序列化結果呼叫本地服務 本地服務執行並將處理結果返回給 server stub server stub 將結果序列化並發送至 client stub client stub 接收到訊息，並進行反序列化 client 得到最終結果 Ref 怎么理解rpc，既然有http请求了为啥还要用rpc？ 谁能用通俗的语言解释一下什么是 RPC 框架？</description></item><item><title>哲學問題 - 忒修斯之船 (Ship of Theseus)</title><link>https://HoshikawaRyuukou.github.io/posts/%E5%93%B2%E5%AD%B8%E5%95%8F%E9%A1%8C-%E5%BF%92%E4%BF%AE%E6%96%AF%E4%B9%8B%E8%88%B9-ship-of-theseus/</link><pubDate>Sun, 06 Nov 2022 21:20:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E5%93%B2%E5%AD%B8%E5%95%8F%E9%A1%8C-%E5%BF%92%E4%BF%AE%E6%96%AF%E4%B9%8B%E8%88%B9-ship-of-theseus/</guid><description>問題 1世紀時的希臘作家普魯塔克問到
如果忒修斯的船上的木頭逐漸被替換，直到所有的木頭都不是原來的木頭，那這艘船還是原來的那艘船嗎？
思考 這艘船在被賦予存在意義之前，就不過是一堆木頭與金屬，如果沒有使用他的人，那麼船將沒有他的意義。因此只要賦予它存在意義的人還在，或者說這份存在意義能夠被繼承下去，無論它變成什麼樣子，它還是那艘船。</description></item><item><title>你好! Hugo</title><link>https://HoshikawaRyuukou.github.io/posts/%E4%BD%A0%E5%A5%BD-hugo/</link><pubDate>Sat, 05 Nov 2022 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E4%BD%A0%E5%A5%BD-hugo/</guid><description>Blog 起初筆者覺得使用 Github Repository + Markdown 當作筆記就足矣。但隨著筆記越多越雜，只使用文件夾結構 + 目錄超連結，在查找上越覺得不便，還是需要有一套系統來代勞。Blog/筆記 平台玲瑯滿目，但寄身於平台的風險難以忽視(倒站/政策改變)，網站搬家也讓人很頭疼。之前就知道靜態網站能架在 Github 上，只是一直沒研究，剛好趁這個機會練習一下 Web 前端的技能。最後的方案是 Github Pages + Hugo。
Hugo 網上的教學也很多，筆者先是快速瀏覽一下幾篇文章再動工，這裡就不手把手介紹，這主要記錄一些筆者遇到的坑。
Hugo 貼身打造個人部落格系列 網站開張！在 GitHub Pages 架設 Hugo 靜態網站 開始 官方的文件 Official Doc 已經足夠清楚了，照著 Quick Start 跑完就有一個完整的畫面(以靜態網站來說)，但這裡有幾個注意的點。
使用 Binary (Cross-platform) 配置 Hugo 時，有 hugo / hugo_extended 版本，且要手動配置環境變數。extended 支援 Sass/SCSS，這裡沒注意到花了不少時間，想說改個主題佈局怎麼編譯不過，Hugo Discourse Support。 設置 .gitignore 主題 主題有很多選擇 Official Link / Github Tag - hugo-theme，有的已經打磨得很完善。筆者對這個 Blog 希望以簡潔明快為主，紀錄是第一要務。最終採用這個 Theme - Cactus (變心可換問題不大)，之後肯定會進行一些魔改的，不然自架的意義就小很多了。
選擇上幾點注意
避開一些太舊的主題 (跟 Hugo 衝突 / js腳本過舊&amp;hellip;) 第三方 API 遇到大改動時要排除一下才能建置 ( FB / IG 讓好多主題要改&amp;hellip;) 修改上幾點注意</description></item></channel></rss>