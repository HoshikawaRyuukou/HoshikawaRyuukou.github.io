<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Design on 識之箱庭</title><link>https://HoshikawaRyuukou.github.io/categories/design/</link><description>Recent content in Design on 識之箱庭</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>HoshikawaRyuukou</copyright><lastBuildDate>Sat, 10 Dec 2022 20:05:00 +0000</lastBuildDate><atom:link href="https://HoshikawaRyuukou.github.io/categories/design/index.xml" rel="self" type="application/rss+xml"/><item><title>邏輯與畫面分離 - MVP 與 MVVM</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%82%8F%E8%BC%AF%E8%88%87%E7%95%AB%E9%9D%A2%E5%88%86%E9%9B%A2-mvp-%E8%88%87-mvvm/</link><pubDate>Sat, 10 Dec 2022 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%82%8F%E8%BC%AF%E8%88%87%E7%95%AB%E9%9D%A2%E5%88%86%E9%9B%A2-mvp-%E8%88%87-mvvm/</guid><description>導覽 網上已經有很多不錯的文章，再寫一份類似的整理文章意義也不大，對 MVP / MVVM 感到陌生，不妨閱讀以下連結，會幫助你理解 MV系列 的發展。因此這裡提出一些使用場合與風險考量。
界面之下：还原真实的MV*模式 正确认识 MVC/MVP/MVVM 站在思想层面看MVX架构 MVP Pattern: Part 2 Supervising Controller Part 2 — Converting Presenters into ViewModels 前述 眾所周知畫面(View)的變更需求是很高的，因此會希望邏輯與畫面分離，以實現關注點分離（separation of concerns）。
邏輯專注於業務處理。 畫面專注於使用者互動。 但分開的事務之間仍需溝通，因此需要有單位出來做協調，MVP 與 MVVM 兩者以不同方式來實作。
MVP - Presenter MVVM - ViewModel 題外話 筆者不使用&amp;quot;優點/缺點&amp;quot;而用&amp;quot;場合/風險&amp;quot;，因為優點/缺點是要看上下文的。 MVP ( Model-View-Presnter) 中介者模式( Mediator Pattern )，Presenter 協調 Model 與 View，使邏輯與畫面解耦。 Presnter 依照依賴倒置原則開出 IView 介面讓 View 來實作，以達到無痛切換 View。而 View 設計成 Passive View 完全被 Presnter 操控。 場合 筆者開發預設使用 MVP，因為其設計風格是命令式的，編寫上較為直覺，且不需額外的擴充功能便可實踐(只需依賴倒置)，實作成本低。 當上下文是純粹輸出時，比較沒有狀態的概念時(數據不會被二次參考)。 Ex: 戰鬥傷害數值呈現，僅在畫面中閃過即結束。 風險 狀態很容易最終分散在 Presenter 和 View 之中，畢竟很直覺地把數據倒給了 View 。如果上下文中&amp;quot;狀態&amp;ldquo;很重要的話，可以評估採用 MVVM 。</description></item><item><title>FlowControl</title><link>https://HoshikawaRyuukou.github.io/posts/flowcontrol/</link><pubDate>Wed, 16 Nov 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/flowcontrol/</guid><description>以下 Feature 指的是一個功能獨立的模塊 (畫面 ⇄ 業務)，Feature A 將簡稱 A。
問題 應用程式中有一個由 A 到 B 的導航，那這個導航是誰的責任? 以下討論三種狀況。
A 直接依賴 B 由 A 將 B 實例化並操作他，簡單粗暴。但出現強耦合，強耦合不是問題但他破壞了 A 的獨立性。當流程發生變化時，可能需要到各個 Feature 去修改。
Feature A -&amp;gt; new Feature B Feature A -&amp;gt; Open Feature B A 引入導航器使其能導航到 B 這作法將導航操作收斂到導航器中，但 A 仍然隱含的知道 B，這同樣破壞了 A 的獨立性。
Feature A -&amp;gt; INavigator.Route(View.FeatureB) // Enum or Feature A -&amp;gt; INavigator.Route(&amp;#34;FeatureB&amp;#34;) // 魔術字串 or Feature A -&amp;gt; INavigator.RouteFeatureB() 導航是獨立操作 說到底 Feature 應該知道自己是能夠被導航或是能導航到哪嗎?</description></item></channel></rss>