<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>識之箱庭</title><link>https://HoshikawaRyuukou.github.io/</link><description>Recent content on 識之箱庭</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>HoshikawaRyuukou</copyright><lastBuildDate>Tue, 22 Nov 2022 21:11:00 +0000</lastBuildDate><atom:link href="https://HoshikawaRyuukou.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>資源-素材</title><link>https://HoshikawaRyuukou.github.io/posts/%E8%B3%87%E6%BA%90-%E7%B4%A0%E6%9D%90/</link><pubDate>Tue, 22 Nov 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E8%B3%87%E6%BA%90-%E7%B4%A0%E6%9D%90/</guid><description>Color Coolors Palettable Icon ICOOON MONO iconmonstr Font 中文免費字體 Audio 魔王魂</description></item><item><title>FlowControl</title><link>https://HoshikawaRyuukou.github.io/posts/flowcontrol/</link><pubDate>Wed, 16 Nov 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/flowcontrol/</guid><description>以下 Feature 指的是一個功能獨立的模塊 (畫面 ⇄ 業務)，Feature A 將簡稱 A。
問題 應用程式中有一個由 A 到 B 的導航，那這個導航是誰的責任? 以下討論三種狀況。
A 直接依賴 B 由 A 將 B 實例化並操作他，簡單粗暴。但出現強耦合，強耦合不是問題但他破壞了 A 的獨立性。當流程發生變化時，可能需要到各個 Feature 去修改。
Feature A -&amp;gt; new Feature B Feature A -&amp;gt; Open Feature B A 引入導航器使其能導航到 B 這作法將導航操作收斂到導航器中，但 A 仍然隱含的知道 B，這同樣破壞了 A 的獨立性。
Feature A -&amp;gt; INavigator.Route(View.FeatureB) // Enum or Feature A -&amp;gt; INavigator.Route(&amp;#34;FeatureB&amp;#34;) // 魔術字串 or Feature A -&amp;gt; INavigator.RouteFeatureB() 導航是獨立操作 說到底 Feature 應該知道自己是能夠被導航或是能導航到哪嗎?</description></item><item><title>Unity Module</title><link>https://HoshikawaRyuukou.github.io/posts/unity-guide/</link><pubDate>Sat, 12 Nov 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-guide/</guid><description>Package Manager Installing Packages using UPM Package manager -&amp;gt; Advanced project settings Add Scoped Registries Name: package.openupm.com URL: https://package.openupm.com Scope(s): com.cysharp.unitask Package manager -&amp;gt; Packages: My Registries -&amp;gt; Install Dependency Injection VContainer
openupm - jp.hadashikick.vcontainer
P.S. How to avoid Dependency Injection constructor madness? Rx (Reactive Extensions) UniRx openupm - com.neuecc.unirx Async UniTask openupm - com.cysharp.unitask Messaging MessagePipe openupm - com.cysharp.messagepipe</description></item><item><title>Unity Reference</title><link>https://HoshikawaRyuukou.github.io/posts/unity-reference/</link><pubDate>Fri, 11 Nov 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-reference/</guid><description>Blog 渋谷ほととぎす通信 きゅぶろぐ LIGHT11</description></item><item><title>初探 RPC</title><link>https://HoshikawaRyuukou.github.io/posts/rpc-%E5%88%9D%E6%8E%A2/</link><pubDate>Mon, 07 Nov 2022 21:06:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/rpc-%E5%88%9D%E6%8E%A2/</guid><description>RPC (Remote Procedure Call，遠端程序呼叫) 是一種通信協定，多用於分佈式系統的通信。
目的 讓客戶端呼叫遠程函式就像呼叫本地函式一樣。將網路通信封裝成函式來使用，那麼客戶端將不需要關心網路協定/模型。
流程 client 客戶端通過本地呼叫的方式呼叫服務 client stub 接收到請求後將參數序列化成能夠進行網路傳輸的訊息體 client stub 找到服務地址，並將訊息發送給服務端 server stub 收到訊息後進行反序列化 server stub 根據反序列化結果呼叫本地服務 本地服務執行並將處理結果返回給 server stub server stub 將結果序列化並發送至 client stub client stub 接收到訊息，並進行反序列化 client 得到最終結果 參考 怎么理解rpc，既然有http请求了为啥还要用rpc？ 谁能用通俗的语言解释一下什么是 RPC 框架？</description></item><item><title>忒修斯之船</title><link>https://HoshikawaRyuukou.github.io/posts/%E5%BF%92%E4%BF%AE%E6%96%AF%E4%B9%8B%E8%88%B9/</link><pubDate>Sun, 06 Nov 2022 21:20:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E5%BF%92%E4%BF%AE%E6%96%AF%E4%B9%8B%E8%88%B9/</guid><description>忒修斯之船（Ship of Theseus） 問題 1世紀時的希臘作家普魯塔克問到
如果忒修斯的船上的木頭逐漸被替換，直到所有的木頭都不是原來的木頭，那這艘船還是原來的那艘船嗎？
思考 這艘船在被賦予存在意義之前，就不過是一堆木頭與金屬，如果沒有使用他的人，那麼船將沒有他的意義。因此只要賦予它存在意義的人還在，或者說這份存在意義能夠被繼承下去，無論它變成什麼樣子，它還是那艘船。</description></item><item><title>你好! Hugo</title><link>https://HoshikawaRyuukou.github.io/posts/%E4%BD%A0%E5%A5%BD-hugo/</link><pubDate>Sat, 05 Nov 2022 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E4%BD%A0%E5%A5%BD-hugo/</guid><description>Blog 起初筆者覺得使用 Github Repository + Markdown 當作筆記就足矣。但隨著筆記越多越雜，只使用文件夾結構 + 目錄超連結，在查找上越覺得不便，還是需要有一套系統來代勞。Blog/筆記 平台玲瑯滿目，但寄身於平台的風險難以忽視(倒站/政策改變)，網站搬家也讓人很頭疼。之前就知道靜態網站能架在 Github 上，只是一直沒研究，剛好趁這個機會練習一下 Web 前端的技能。最後的方案是 Github Pages + Hugo。
Hugo 網上的教學也很多，筆者先是快速瀏覽一下幾篇文章再動工，這裡就不手把手介紹，這主要記錄一些筆者遇到的坑。
Hugo 貼身打造個人部落格系列 網站開張！在 GitHub Pages 架設 Hugo 靜態網站 開始 官方的文件 Official Doc 已經足夠清楚了，照著 Quick Start 跑完就有一個完整的畫面(以靜態網站來說)，但這裡有幾個注意的點。
使用 Binary (Cross-platform) 配置 Hugo 時，有 hugo / hugo_extended 版本，且要手動配置環境變數。extended 支援 Sass/SCSS，這裡沒注意到花了不少時間，想說改個主題佈局怎麼編譯不過，Hugo Discourse Support。 設置 .gitignore 主題 主題有很多選擇 Official Link / Github Tag - hugo-theme，有的已經打磨得很完善。筆者對這個 Blog 希望以簡潔明快為主，紀錄是第一要務。最終採用這個 Theme - Cactus (變心可換問題不大)，之後肯定會進行一些魔改的，不然自架的意義就小很多了。
選擇上幾點注意
避開一些太舊的主題 (跟 Hugo 衝突 / js腳本過舊&amp;hellip;) 第三方 API 遇到大改動時要排除一下才能建置 ( FB / IG 讓好多主題要改&amp;hellip;) 修改上幾點注意</description></item><item><title>About me</title><link>https://HoshikawaRyuukou.github.io/about/</link><pubDate>Wed, 24 Aug 2016 17:51:42 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/about/</guid><description>Github: HoshikawaRyuukou</description></item></channel></rss>