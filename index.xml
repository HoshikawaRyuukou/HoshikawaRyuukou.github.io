<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>識之箱庭</title><link>https://HoshikawaRyuukou.github.io/</link><description>Recent content on 識之箱庭</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>HoshikawaRyuukou</copyright><lastBuildDate>Sat, 02 Dec 2023 21:11:00 +0000</lastBuildDate><atom:link href="https://HoshikawaRyuukou.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>TypeScript - 筆記</title><link>https://HoshikawaRyuukou.github.io/posts/typescript-%E7%AD%86%E8%A8%98/</link><pubDate>Sat, 02 Dec 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/typescript-%E7%AD%86%E8%A8%98/</guid><description>入門 《JavaScript 教程》 ES6 教程 TypeScript 教程 | 菜鸟教程 TypeScript 教程 阮一峰</description></item><item><title>MAUI - 筆記</title><link>https://HoshikawaRyuukou.github.io/posts/maui-%E7%AD%86%E8%A8%98/</link><pubDate>Tue, 28 Nov 2023 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/maui-%E7%AD%86%E8%A8%98/</guid><description>Learn MAUI这么“烂”，你怎么还好意思讲？——说说我眼中的计算机技术工程教学</description></item><item><title>專案管理 - 策略</title><link>https://HoshikawaRyuukou.github.io/posts/%E5%B0%88%E6%A1%88%E7%AE%A1%E7%90%86-%E7%AD%96%E7%95%A5/</link><pubDate>Fri, 10 Nov 2023 21:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E5%B0%88%E6%A1%88%E7%AE%A1%E7%90%86-%E7%AD%96%E7%95%A5/</guid><description> Data-driven vs Opinion-driven Decision</description></item><item><title>Unity - External Dependency Manager for Unity (EDM4U)</title><link>https://HoshikawaRyuukou.github.io/posts/unity-external-dependency-manager-for-unity-edm4u/</link><pubDate>Wed, 08 Nov 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-external-dependency-manager-for-unity-edm4u/</guid><description>前言 Google 停止維護 Game Package Registry (GPR) 導致不能直接使用 Package Manager 導入包。必須到封存檔網站下載「.tgz」手動導入。
Google Unity 套件 Install a package from a local tarball file 其他的相關的 Google Service 依賴(AR/Firebase/Google Play等)也可以用此方法導入。
設定 Assets → External Dependency Manager → Android Resolver → Settings，啟用這三個 Patch 並至 Player Settings → Publishing Settings 啟用以下選項</description></item><item><title>Game Design - 分析</title><link>https://HoshikawaRyuukou.github.io/posts/game-design-%E5%88%86%E6%9E%90/</link><pubDate>Sat, 23 Sep 2023 21:12:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/game-design-%E5%88%86%E6%9E%90/</guid><description> 从没讲过的音乐出现了!蔚蓝档案的音乐什么水平？丨HOPICO</description></item><item><title>Godot - Sites</title><link>https://HoshikawaRyuukou.github.io/posts/godot-sites/</link><pubDate>Fri, 22 Sep 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/godot-sites/</guid><description>Sites 2dgames.jp</description></item><item><title>Unity - Basic - Asset Management</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-asset-management/</link><pubDate>Sat, 09 Sep 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-asset-management/</guid><description>AssetBundle Assets, Resources and AssetBundles Case Studies of Unity AssetBundle Efficient Encryption Frameworks Addressables Addressables YooAsset tuyoogame/YooAsset</description></item><item><title>通用設計 - Pattern - ViewModel</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-pattern-viewmodel/</link><pubDate>Sun, 27 Aug 2023 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-pattern-viewmodel/</guid><description>前述 此篇的實作參考到以下文件 (提到不少 Presentation layer 設計原則)
Android Developers 文件/指南/UI 層
該文件的更新頻率算高且會與時俱進，筆者印象中其架構設計從 MVVM -&amp;gt; Domain/Application Driven 設計，可以看出主流架構有產生變化。之後的討論雖然使用 ViewModel 但不會詳細介紹 MVVM 的細節，如果對 MVX 系列不熟，可以先讀筆者之前的文章 &amp;laquo;通用設計 - Pattern - MVP&amp;raquo; 裡面的 References。
探索 回到正題，筆者在最近的業務上遇到
如何在 服務端未完成 的情況下，讓 Client 獲得完整的體驗流 ?
以下用交叉反問的方式來分析問題
Q: 沒有服務端那資料來源哪來 ? A: 使用假資料
Q: 當表現層依賴的是 IService Interface 使用假資料時需要實作什麼 ? A: 只需要實作一個 FakeService 來產生假資料即可
Q: 當想要將業務與表現解耦時，很常使用中介者的手法來黏合兩者，如果使用標準的 MVP 實做，Presenter 實際做了哪些事呢 ? A: 監聽 View 事件/ 與 Service 互動/ 管理畫面狀態/ 呼叫 View 刷新</description></item><item><title>Unity - Packages</title><link>https://HoshikawaRyuukou.github.io/posts/unity-packages/</link><pubDate>Thu, 03 Aug 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-packages/</guid><description>Package Manager Installing Packages using UPM Package manager -&amp;gt; Advanced project settings Add Scoped Registries Name: package.openupm.com URL: https://package.openupm.com Scope(s): com.cysharp.unitask Package manager -&amp;gt; Packages: My Registries -&amp;gt; Install Unity中 .asmdef文件的作用 使用OpenUPM发布自己的Unity项目 开发Unity PackageManager 插件包 Creating Custom Packages for Unity 2018.3 How to remodel your project for asmdef and UPM Private GitHub repository Install Unity Package from a private GitHub repository 至 GitHub &amp;laquo;帳戶設定&amp;raquo;（非儲存庫設定） Developer Settings -&amp;gt; Personal Access Tokens -&amp;gt; Fine-Grained Tokens 生成 Token (Read-Only Permission for the repo Content).</description></item><item><title>Unity - Basic - Memory Profiler</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-memory-profiler/</link><pubDate>Sun, 30 Jul 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-memory-profiler/</guid><description>注意 由於Unity 無法將性能分析器本身佔用的記憶體與運行模式的記憶體完全分開。要獲得應用程序的更精確數字和記憶體使用情況，應在要運行應用程序的目標設備和操作系統上分析應用程序。 如果需要在記憶體受限的平台上運行應用程序，設備上的總駐留量對於檢查低記憶體警告和由於記憶體耗盡而強制關閉非常有用。作為一般規則，它不應超過設備上可用總物理內存的 70%。 偵測 Leaked Managed Shell 的功能在 Memory Profiler 1.1.0-pre.1 Ref Memory Profiler Memory Profiler | 1.1.0-pre.1 - Unity - Manual Unity でメモリリーク？ Memory Profiler で Leaked Managed Shell をチェックしてみよう！ Inspecting memory with the new Memory Profiler package Memory Profiler로 애플리케이션의 물리적 메모리 사용량 분석 Unity内存分析与优化实践(1.1版本前)</description></item><item><title>DevOps - Docker</title><link>https://HoshikawaRyuukou.github.io/posts/devops-docker/</link><pubDate>Sat, 29 Jul 2023 20:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/devops-docker/</guid><description>安裝 筆者的環境是 Windows 10 Home 版，所以需要做些額外設定
參考官網 https://docs.docker.com/desktop/install/windows-install/ 到 控制台\程式集\程式和功能 -&amp;gt; 開啟或關閉 Windows 功能 啟用 Windows 子系統 Linux版 與 虛擬機器平台 執行 Docker Desktop 安裝程序 WSL 2 可能會缺少/版本不夠，照安裝程序提示的指令更新即可 Ref 30分钟Docker入门教程</description></item><item><title>Git - Rebase</title><link>https://HoshikawaRyuukou.github.io/posts/git-rebase/</link><pubDate>Sun, 16 Jul 2023 20:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/git-rebase/</guid><description> 之前筆者一直以為 rebase 是進行類似 剪下貼上 的操作，但實際上是 複製貼上
情境 合併時不會像 merge 時會有 commit 的節點 想整理 還沒推出去 的 commit 可以使用 避免修改已經推出去的歷史 如何取消操作 使用 reflog 列印出所有「歷史紀錄」找到 rebase 的前一個 commit id，並進行 reset 即可
git reflog git reset XXXXXXX --hard 此外當進行比較危險操作時 git 會額外紀錄前一個 head 於 ORIG_HEAD，因此也可以直接執行以下，來達到同樣效果
git reset ORIG_HEAD --hard Ref 另一種合併方式（使用 rebase） git rebase 用法 git rebase -i (drop) git rebase -i (pick) git rebase -i (reword)</description></item><item><title>Git - Pull Request</title><link>https://HoshikawaRyuukou.github.io/posts/git-pull-request/</link><pubDate>Fri, 14 Jul 2023 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/git-pull-request/</guid><description> 有的環境也稱 Merge Request
情境 開發產品時一般會挑選固定一個分支做為可以上線的正式版本分支(master)，需注意的是在進行多人協同開發時，讓每個人都可以 Commit 到專案正式上線的分支不是個好的做法。
可以透過 pull request 方式控管權限，由負責管理這個專案的人收到其他開發者的 pull request 並確認無誤後便可進行合併，來確保產品分支處於隨時都是可上線的狀態。
參與開源專案時，在創建 pull request 之前，建議先在本地分支上運行 git rebase 命令，確保你的更改基於最新的進度以降低審查者的理解難度。
Ref 與其它開發者的互動 - 使用 Pull Request（PR）</description></item><item><title>C-Sharp - Basic - 前置處理器指示詞</title><link>https://HoshikawaRyuukou.github.io/posts/c-sharp-basic-%E5%89%8D%E7%BD%AE%E8%99%95%E7%90%86%E5%99%A8%E6%8C%87%E7%A4%BA%E8%A9%9E/</link><pubDate>Fri, 07 Jul 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/c-sharp-basic-%E5%89%8D%E7%BD%AE%E8%99%95%E7%90%86%E5%99%A8%E6%8C%87%E7%A4%BA%E8%A9%9E/</guid><description>前述 筆者最近接觸到的遺舊專案中發現裡面大量地使用 條件式編譯
#if DEBUG Console.WriteLine(&amp;#34;Debug version&amp;#34;); #endif 筆者之前有使用也基本只使用 定義區域 (排版效果)
#region MyClass definition public class MyClass { static void Main(){...} } #endregion Unity 在處理平台裝置時也蠻常會出現的
public class PlatformDefines : MonoBehaviour { void Start () { #if UNITY_EDITOR Debug.Log(&amp;#34;Unity Editor&amp;#34;); #endif #if UNITY_IOS Debug.Log(&amp;#34;iOS&amp;#34;); #endif #if UNITY_STANDALONE_OSX Debug.Log(&amp;#34;Standalone OSX&amp;#34;); #endif #if UNITY_STANDALONE_WIN Debug.Log(&amp;#34;Standalone Windows&amp;#34;); #endif } } 問題 那前置處理器指示詞有什麼問題呢? (參考日文那個 Ref 有比較明確的 Case)
編譯版本至少會是 2^(指示詞的分類數)種，持續的調試和測試變得非常困難。 Unit Test 中難以使用。 編譯檢查不起作用。 當巢狀結構出現時可讀性將大為降低。 上述這些狀況都會導致 延後發現問題的時間 !</description></item><item><title>Unity - Basic - iOS plug-in</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-ios-plug-in/</link><pubDate>Wed, 05 Jul 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-ios-plug-in/</guid><description>前述 這次的業務需求是
取得 ios 實機的 &amp;ldquo;地區&amp;rdquo;，並讓 C# 能拿到 Swift 所返回的字串
因為在 ios 的環境下 unity / C# 拿到的值並不正確。此外筆者對 Swift / Objective-C 幾乎零基礎，目前只針對一些教學文件做些修改，之後有機會更熟再回頭深究。
實作 SwiftDeviceInfoPlugin.swift 須放置於 Plugins\iOS 之下 import Foundation public class SwiftDeviceInfoPlugin { public static func getRegion() -&amp;gt; String { return Locale.current.regionCode ?? &amp;#34;Unknown&amp;#34; } } @_cdecl(&amp;#34;getRegion&amp;#34;) public func getRegion() -&amp;gt; UnsafePointer&amp;lt;CChar&amp;gt;? { let region = strdup(SwiftDeviceInfoPlugin.getRegion()) return UnsafePointer(region) } @_cdecl(&amp;ldquo;getRegion&amp;rdquo;)：這是一個 Swift 標記，表示下面的函數將使用cdecl樣式的名稱綁定。您只需知道此屬性向 C 公開了一個 Swift 函數 UnsafePointer&amp;lt;CChar&amp;gt;?，它是一個可為空的指向 C 風格字串（CChar）的指標。這使得 Swift 能夠以與 C 相容的方式提供訪問區域資訊的介面。 strdup() 用於創建預返回的字串的副本，並在堆上分配其記憶體。 public sealed class IOSDeviceInfoProvider : IDeviceInfoProvider { public string GetRegion() { return new System.</description></item><item><title>通用設計 - Pattern - Service Locator</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-pattern-service-locator/</link><pubDate>Wed, 28 Jun 2023 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-pattern-service-locator/</guid><description>前述 Service Locator 確實也是 IoC 的一種實作方式，不過採用的是 依賴尋找(Dependency Lookup) 的設計。 筆者之前有一陣子蠻常使用這 pattern，那時對 DI 與 IoC 的概念並不熟悉，只覺得這樣使用依賴變得很方便。
因為我可以在任何地方直接這樣取用資源
var target = ServiceLocator.Resovle&amp;lt;Target&amp;gt;(); 這樣的寫法有以下問題 :
透過 ServiceLocator 因為這個取用資源的過程是隱性的，不容易被直接發現。 想用誰就拿誰這件事也有點危險，Ex: View 可以拿到不屬於 Presentation layer 該碰的對象。 所以當 DI 與 IoC 的概念熟悉後，並且使用 DI / IoC Container 後就漸漸不使用這 pattern 了。
應用 但這次工作上反而覺得 Service Locator 可以勝任從 Singleton 過渡到 DI / IoC Container 的中繼階段。
因為這次接觸到的專案嚴重依賴 Singleton，且組員也已習慣 Singleton 的寫法了，要直切換到 DI / IoC Container 會有不小的陣痛期(當然實務上能不能切又是另一個故事了)。
於是筆者想起了 Service Locator，有以下理由
因為在使用上就很像是 Singleton 筆者希望組員能快速感受到 IoC 所帶來的紅利 集中管理依賴 實作 此模式使用稱為「服務定位器」的中央註冊表，它根據請求返回執行特定任務所需的對象。</description></item><item><title>FileFormat - WebP</title><link>https://HoshikawaRyuukou.github.io/posts/fileformat-webp/</link><pubDate>Thu, 22 Jun 2023 20:20:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/fileformat-webp/</guid><description>設計目標 Google 以縮減線上影像的檔案大小為目標，同時維持不輸 JPEG、PNG、GIF 格式的圖片品質。
網站的瀏覽與速度不僅影響使用者的耐心，也會影響SEO的排名與檢索，透過顯著縮減相片和圖形大小，網頁就能加快載入速度，提供更優質的使用者體驗。
並持續在優化 WebP 2: experimental successor of the WebP image format
壓縮方式 有損壓縮 無失真壓縮 Ref WebP 檔案 Now in REALITY Tech #6 画像をWebP形式に対応した話 Now in REALITY Tech #37 UnityでWebPを扱えるようにした話</description></item><item><title>Test - NUnit</title><link>https://HoshikawaRyuukou.github.io/posts/test-nunit/</link><pubDate>Wed, 07 Jun 2023 22:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/test-nunit/</guid><description>Ref Doc NUnit 幾個參數化測試的方式</description></item><item><title>Test - Unit Test</title><link>https://HoshikawaRyuukou.github.io/posts/test-unit-test/</link><pubDate>Sun, 04 Jun 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/test-unit-test/</guid><description>以下觀點不一定適用於各專案，請因地制宜。
以反面例子來看單元測試 慢 不穩定 脆弱 不方便 問題出在不可控
希望是可控的 可重現一樣結果 以整體專案的角度來看單元測試 專案內分為 不可控 與 可控 兩部分
不可控: 檔案/資料庫/第三方套件 可控: 除不可控以外自己所寫的部分 可控內分為 不可測 與 可測 兩部分
不可測: 與不可控接觸的部分，因此會希望這部分越單純越好。 可測: 為專案內價值較高，須小心維護的部分。 目標: 可測範圍盡量大，不可測盡量小。
FAQ 單元測試相較於手動測試的優勢 ? 可以輕鬆的跑完多個 Test Cases Static 要不要測 ? 直接使用真實行為 透過測試框架強測 重構/隔離/依賴注入 Ref 一起設計出可被單元測試的程式碼吧！ [Day 2]Unit Testing 簡介 .NET Core 和 .NET Standard 的單元測試最佳做法</description></item><item><title>Test - 概述</title><link>https://HoshikawaRyuukou.github.io/posts/test-%E6%A6%82%E8%BF%B0/</link><pubDate>Sat, 03 Jun 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/test-%E6%A6%82%E8%BF%B0/</guid><description>以下觀點不一定適用於各專案，請因地制宜。
在開始寫 code 之前 測試文化: 底下的人願意寫，上面的人願意給時間。 測試的順位: 從商業價值最高的功能開始。 較低的測試價值 需求尚未明朗又必須交付成果。 取決於經營者對價值的認定，其實跟程式沒多大關係。 不是所有的程式都可以測試，有時候為了測試，程式需要先重構成可以測試的樣子。 Ref 一次搞懂單元測試、整合測試、端對端測試之間的差異</description></item><item><title>Unity - Package - xLua</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-xlua/</link><pubDate>Sun, 28 May 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-xlua/</guid><description>本次操作 xLua 主要是做熱更方案的評估測試，筆者目前還是偏好使用 HybridCLR。
Official Tencent/xLua 評估 使用 lua 仍是目前主流/穩定做法 (畢竟也行之有年了)。 邏輯操作可能要移師到 lua 側。 缺少 ide 支援如果要在 lua 側 進行 unity 相關操作時，維護/除錯成本極高。 Example 在 lua 側進行 unity 相關操作
local speed = 10 local lightCpnt = nil function start() print(&amp;#34;lua start...&amp;#34;) print(&amp;#34;injected object&amp;#34;, lightObject) lightCpnt= lightObject:GetComponent(typeof(CS.UnityEngine.Light)) end function update() local r = CS.UnityEngine.Vector3.up * CS.UnityEngine.Time.deltaTime * speed self.transform:Rotate(r) lightCpnt.color = CS.UnityEngine.Color(CS.UnityEngine.Mathf.Sin(CS.UnityEngine.Time.time) / 2 + 0.5, 0, 0, 1) end function ondestroy() print(&amp;#34;lua destroy&amp;#34;) end</description></item><item><title>Unity - Editor - ScriptedImporter</title><link>https://HoshikawaRyuukou.github.io/posts/unity-editor-scriptedimporter/</link><pubDate>Sat, 27 May 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-editor-scriptedimporter/</guid><description>用途 使用C# 為Unity 本身不支持的文件格式編寫自定義資源導入器，從而添加支持。 注意 Scripted Importer 無法處理已由 Unity 本身處理的文件擴展名。 Example 這裡將 .lua 以 TextAsset
using UnityEngine; using System.IO; using UnityEditor.AssetImporters; [ScriptedImporter( 1, &amp;#34;lua&amp;#34; )] public class LuaImporter : ScriptedImporter { public override void OnImportAsset( AssetImportContext ctx ) { TextAsset subAsset = new TextAsset( File.ReadAllText( ctx.assetPath ) ); ctx.AddObjectToAsset( &amp;#34;text&amp;#34;, subAsset ); ctx.SetMainObject( subAsset ); } } Ref Scripted Importers [Unity] 资源工作流程 - ScriptedImporter</description></item><item><title>通用設計 - Inversion of Control (IoC)</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-inversion-of-control-ioc/</link><pubDate>Fri, 05 May 2023 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-inversion-of-control-ioc/</guid><description>反轉了什麼 ? 依賴對象的獲得被反轉了
在應用程式中設計總會有多個單元需要合作的情況，這時就會有配置依賴的需求，但這個配置應該由需求方來處理嗎?
讓依賴需求方自己處理最簡單的方式就是實例化(new)，但這可能會有以下問題:
不同需求方重複 new 是否會有浪費的問題? 能被共用嗎? 方便共用嗎? 到處 new 來 new 去，依賴的管理變得很亂 那不如找一個單位負責來處理依賴配置。我不自己 new，而是別人 new 完後(注入給我/讓我查找)，這麼所帶來的好處:
資源複用更方便: 統一由容器創建或保存對象，不需要每個需求方都自己 new 一個新的。 建造/使用分離: 依賴需求方操作其依賴項來完成任務才是他主要的責任，如果還要處理依賴項的實例化，責任就模糊了，因此將依賴項的創建和配置的控制權交給 IoC Container。 為此需要有一個 IoC Container 來處理，通常容器包含以下操作：
Register：註冊類型和依賴關係 Resolve：創建並註入依賴關係 Dispose：管理生命週期 實踐方式 最常見的方式分別是 依賴注入（Dependency Injection，DI）與 依賴尋找（Dependency Lookup）。
依賴尋找 可以簡單理解為 依賴需求方 &amp;laquo; 主動 &amp;raquo; 使用容器來取得依賴。依賴需求方直接使用 Locator.Resolve 取得依賴，但這種作法有些爭議(反模式)，依賴需求方是不是有註冊的項目都能任意取得阿 ?
Service Locator 服務定位器是依賴尋找的典型實作。
依賴注入 透過注入依賴項讓 依賴需求方 &amp;laquo; 被動 &amp;raquo; 使用容器來取得依賴，常透過三種方式注入。
建構子(推薦) 屬性 方法 權限相對清晰(建構子注入)，能用依賴項的都在建構子給你了，不過你要額外new 其他東西也是沒人攔得住。
這個方式通常透過框架來處理，此外依賴需求方是不知道容器的存在(理想狀態，但有時會需要一些注入標記)。</description></item><item><title>Unity - Package Manager</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-manager/</link><pubDate>Sat, 22 Apr 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-manager/</guid><description>Package Samples 對應有些模組的操作比較複雜繁瑣，有時需要有一些 Sample 做參考。官方 Package Manager 有個 &amp;ldquo;半套&amp;rdquo; Sample 工作流，讓人不是很舒服。
官方文件
Sample 資料夾後面加了波浪號 (~) 告訴 Unity 忽略 Samples~ 文件夾中的內容，此類文件夾不使用.meta文件進行跟踪。忽略 Samples~ 對 Package 使用者是好的，畢竟不是每個人都需要。
但對 Package 開發者，畢竟 Samples 也是要進版控的，而這樣改名的作法會徒增一些重命名的提交也有點煩躁(除非在修改 Sample 的過程中完全不提交)。原先想說寫個 Samples ↔ Samples~ 切換的腳本就好，會一直有 meta 檔的警告(刪掉/改名都還是在)。
官方作法 論壇中的某篇討論才記載他們的做法(倒是加到文件中阿&amp;hellip;)
在內部確實使用了名為 Samples 的文件夾 (沒有 Samples~ ) 在推送新包版本之前通過腳本對其進行重命名(透過 CI ) OpenUPM 的作者也是使用類似的工作流，總之筆者也調整為上述的方式。
透過 GitHub Actions Workflow 調整目錄名 筆者不熟 GitHub Actions/ YAML/ 文件操作，但這種初階的操作就交由 chatgpt 代勞，幫我省去不少實驗成本。這裡的操作只是堪用，應該有更好的方式。
以下是筆者要求的條件
想透過 GitHub Actions 中的 workflow 完成 如果 forPackage 分支已存在則將其刪除 從 main 建立新的 forPackage 分支 Assets/Modules 的所有子目錄(同時有 &amp;ldquo;package.</description></item><item><title>Unity - Package - HybridCLR</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-hybridclr/</link><pubDate>Tue, 11 Apr 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-hybridclr/</guid><description>先備知識 Assembly Definition (Asmdef) Unity 2017.3 以上版本的提供功能，主要解決龐大的程序集編譯時效率問題。
具體內容建議閱讀 Doc - Assembly definitions
Assembly-CSharp.dll Unity 預設整合的 dll，專案內未被劃分進自定義 Asmdef 的腳本都會被整合進 Assembly-CSharp.dll
簡述 HybridCLR focus-creative-games/hybridclr focus-creative-games/hybridclr_trial HybridCLR 筆者已經應用於工作環境好一陣子了(從 2.X 版本開始)，其最讓人驚豔的地方在於，過往的開發流幾乎不用更動(當然要好 Asmdef 的規劃)，僅在打包時調整一下工作流即可。
其極大簡化過往麻煩且效率不彰的熱更流程。xLua 和 ILRuntime 在筆者看來最難受的事是「侵入性」極強，有時為了熱更必須將業務邏輯移到 Lua 和 ILRuntime，搞得綁手綁腳。大家也都抱怨很久了，但也沒有其他可靠方案，直到 HybridCLR 出現。
快速上手 3.0 版本後流程優化得更順暢了，照著 文件 可以很快地感受到其威力。
注意 请问，Generate All、补充元数据的DLL更新的执行时机的最佳实践？ 怎么卸载热更dll CLI 規範中只能以 AppDomain 形式卸載所有 dll，不支持卸載單獨的 dll。而 il2cpp 是單例 AppDomain，因此這個要求是不符合規範的。要採用 HybridCLR DHE 的商業方案。不過筆者倒是不太擔心，畢竟 Unity client 通常不是需要常駐的應用，使用者也不太會把應用的每一個功能都點一遍，初估是還可以接受的。</description></item><item><title>AI - 雜記</title><link>https://HoshikawaRyuukou.github.io/posts/ai-%E9%9B%9C%E8%A8%98/</link><pubDate>Mon, 10 Apr 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/ai-%E9%9B%9C%E8%A8%98/</guid><description> 2023 Generative AI（AIGC 詠唱者年會）活動筆記</description></item><item><title>Unity - Basic - DontDestroyOnLoad</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-dontdestroyonload/</link><pubDate>Mon, 20 Mar 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-dontdestroyonload/</guid><description>用例 被標記為 DontDestroyOnLoad 的物件場景更改時不會被破壞。
全域管理器：因為整個遊戲期間一直存在。例如，音效管理器、遊戲設定管理器或玩家數據管理器等物件可以在場景切換時保留，以確保它們的功能和數據在各個場景中持續存在。 持久性數據：如果你有需要在多個場景中共享的持久性數據，可以將存儲這些數據的物件標記為 DontDestroyOnLoad。例如，玩家的遊戲進度或全域的配置設置等數據可以在場景切換時保留，以便在不同場景中訪問和更新。 UI 元素：某些UI元素，如遊戲狀態面板、計時器或得分顯示，可能需要在多個場景中保留。通過將這些UI元素物件標記為 DontDestroyOnLoad，可以確保它們在場景切換時不會被銷毀，以便在不同場景中持續顯示和更新。 問題 記憶體管理問題：使用 DontDestroyOnLoad 將遊戲物件保留在多個場景中可能會導致記憶體洩漏。如果你的遊戲物件不再需要，但沒有被正確銷毀，它們將繼續存在於記憶體中，佔用系統資源，可能導致性能下降。 場景管理問題：DontDestroyOnLoad 會打破場景之間的清晰界限。場景是 Unity 中組織和管理遊戲邏輯的基本單位，每個場景都應該是相對獨立的。通過在多個場景之間保持物件，會增加場景之間的耦合性，導致代碼難以維護和測試。 Ref Object.DontDestroyOnLoad</description></item><item><title>AI - Stable Diffusion</title><link>https://HoshikawaRyuukou.github.io/posts/ai-stable-diffusion/</link><pubDate>Fri, 10 Mar 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/ai-stable-diffusion/</guid><description>安裝 安裝Stable Diffusion WebUI
頻道 萌芽綜合天地 - Stable Diffusion web UI 人工治障 杰克艾米立 AIツール関係 社群 Civitai AI 그림 채널 畫廊 Prompt Search chichi-pui PixAI.Art Prompt AI繪圖魔導書 NovelAI魔咒小课堂 NovelAI tag生成器 V2.1 【Stable Diffusion】プロンプト（呪文）ガイド 知識點 Stable diffusion采样器全解析，30种采样算法教程 【Stable diffusion技巧教程】解决图片模糊！4这种不同方法实现AI高清放大 【Stable diffusion技巧教程】深入分析二次元风AI跑图脸崩，假脸的解决方法 图生图终极指南：从玩具到工具！ 案例 【Stable diffusion案例教程】运用AI实现 草图→清稿→上色→3d效果全流程 Extra ImgPilot</description></item><item><title>軟體開發 - 好站連結</title><link>https://HoshikawaRyuukou.github.io/drafts/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC-%E5%A5%BD%E7%AB%99%E9%80%A3%E7%B5%90/</link><pubDate>Fri, 03 Mar 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/drafts/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC-%E5%A5%BD%E7%AB%99%E9%80%A3%E7%B5%90/</guid><description>CodeOpinion
Entropy Wins - A blog on Software Architecture, Design and Craftsmanship
jyt0532&amp;rsquo;s Blog
Tomas Tulka&amp;rsquo;s Blog</description></item><item><title>視覺設計 - 設計原則</title><link>https://HoshikawaRyuukou.github.io/posts/%E8%A6%96%E8%A6%BA%E8%A8%AD%E8%A8%88-%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87/</link><pubDate>Thu, 02 Mar 2023 21:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E8%A6%96%E8%A6%BA%E8%A8%AD%E8%A8%88-%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87/</guid><description>Color 如何找出好配色？照著這個步驟做，讓你的設計更具吸引力！！ 什么是更好的渐变？ Color Tools Stocksy Adobe Color Canva VIVID GRADIENT GENERATOR TOOL</description></item><item><title>AI - ChatGPT 初探</title><link>https://HoshikawaRyuukou.github.io/posts/ai-chatgpt-%E5%88%9D%E6%8E%A2/</link><pubDate>Wed, 01 Mar 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/ai-chatgpt-%E5%88%9D%E6%8E%A2/</guid><description>相關背景 ChatGPT (可能)是怎麼煉成的 - GPT 社會化的過程 【生成式AI】ChatGPT 原理剖析 (1/3) — 對 ChatGPT 的常見誤解 目的 我主要測試兩個方向
寫 程式 能力: 寫程式能力是因為與我工作有關係，反正遲早要來的，早點試試看。 寫 小說 能力: ChatGPT 的本質是文字接龍，因此測一下最純粹的應用。 寫 程式 能力 因為 ChatGPT 是基於舊訊息，所以我選了一個經典的遊戲 &amp;ldquo;貪食蛇&amp;rdquo;，我預計他寫得出來，也確實寫出來。
我希望他以 Clean Architecture 改寫，我預計他寫不出來，但寫出來了(必須說有點嚇到)。大概閱了一下，應該沒有太大問題，不過 Code 基本都會因太長而斷掉，有點麻煩。(圖片只有一部分因為很長)
另外試了一下寶可夢對戰，先詢問使否知道，然後請他以 C# 實作。 拿來做為 Prototype 似乎還行，雖然很多都是寫死的。基本上適當的引導，可以做得更好(先定義屬性/能力/道具&amp;hellip;)，這將是一門新學問。
寫 小說 能力 他的不可預測性對我這種很能靈光一閃的人來說幫助很大，給幾個設定他就開始亂掰(當然可以多設一些限制)。
幾個缺點
會忘設定，因此有時要一直提醒。 上下文連貫，是優點也是缺點? 因為一旦被汙染就沒辦法剃除。只能開一個新的。 強制清新/健康/正能量，常常在末段應轉方向&amp;hellip; Content Policy 首先正常的答案會偏向清新/健康/正能量，會規避負面生成。不過就我查到的資訊來看，檢查機制與生成機制似乎是分開的。此外你不能要求他提供為何會觸發 content policy (小機率可以)
上述的問題哪裡違反 content policy，他會叫你去問 ChatGPT 團隊。 但注意上下文中一旦出現 content policy，很可能導致接下來會越難成功。
ChatGPT 100% 是讀過OO小說的，是寫得出來得。但現在越來越嚴格，需要旁敲側擊。至少使用者的問題不會觸發，以下是我的經驗，成功與否因素很多
前置動作要先聲明 ChatGPT 是小說家在開始</description></item><item><title>Art - Drawing - 筆記</title><link>https://HoshikawaRyuukou.github.io/posts/art-drawing-%E7%AD%86%E8%A8%98/</link><pubDate>Wed, 01 Mar 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/art-drawing-%E7%AD%86%E8%A8%98/</guid><description>Community Pinterest Channel taco1704 hide channel【顔と体の描き方講座】 Practice Line of Action Book ミニキャラの描き方　「ちまっとかわいい」を描く基本＆表現テクニック</description></item><item><title>Unity - WorkFlow - Build &amp; Publish</title><link>https://HoshikawaRyuukou.github.io/posts/unity-workflow-build-publish/</link><pubDate>Mon, 27 Feb 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-workflow-build-publish/</guid><description>Build repositories.cfg could not be loaded. Unable to find player assembly: XXXX\Temp\StagingArea\Data\Managed\UnityEngine.TestRunner.dll Device Quickly preview your game on Android device | Unity tutorial Publish Privacy policy for your game? No problem! (generate and publish) Publish your UNITY game on Google Play Store - 2023 guide</description></item><item><title>Hugo - 筆記</title><link>https://HoshikawaRyuukou.github.io/posts/hugo-%E7%AD%86%E8%A8%98/</link><pubDate>Sat, 25 Feb 2023 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/hugo-%E7%AD%86%E8%A8%98/</guid><description>Install Hugo 從零開始 環境安裝(Windows) Image Rendering Images in Markdown Preview of Hugo Site 以管理員權限開啟 cmd mklink /D images .\static\images</description></item><item><title>架構設計 - Modularization</title><link>https://HoshikawaRyuukou.github.io/posts/%E6%9E%B6%E6%A7%8B%E8%A8%AD%E8%A8%88-clean-architecture-and-modularization/</link><pubDate>Wed, 22 Feb 2023 21:21:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E6%9E%B6%E6%A7%8B%E8%A8%AD%E8%A8%88-clean-architecture-and-modularization/</guid><description>前述 首先幾篇文章是基於 Clean Architecture 的基礎，建議先閱讀以下連結已具備基礎知識
The missing chapter CA 原著 Chapter 34 - The missing chapter - Actual implementation details of an architecture 連結 34章摘要心得，請先觀看裡面的圖表(重要) CA Modularization Multiple ways of defining Clean Architecture layers Package by Component with Clean Modules in Java Package by feature or component Vertical Slice Slices vs. Layers Restructuring to a Vertical Slice Architecture Vertical Slice Architecture, not Layers! Modular Monolith Majestic Modular Monoliths (強烈建議) Modular Monolith architecture (強烈建議讀完這個系列) 各 Package 策略的圖請參考上方連結 34 章摘要心得</description></item><item><title>Unity - Basic - Sprite</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-sprite/</link><pubDate>Mon, 20 Feb 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-sprite/</guid><description>Sprite 【2Dゲームで必須】UnityのSprite（スプライト）の単位をわかりやすく解説 【間違えやすい】Unityの正しい画像サイズとは Atlas 【Unity】SpriteをパックするSpriteAtlasの使い方 目的 減少DrawCall 圖集將圖片打包為2的冪次方的素材大小，可以提升性能 減小包體大小 注意 以 Sprite Atlas V1 - Always Enabled 啟用圖集時 Edit Mode : reference the packed Textures Play Mode : reference the original unpacked Textures</description></item><item><title>Unity - Sites</title><link>https://HoshikawaRyuukou.github.io/posts/unity-sites/</link><pubDate>Mon, 20 Feb 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-sites/</guid><description>Blog 游戏石匠Super L&amp;rsquo;s Blog コガネブログ 渋谷ほととぎす通信 きゅぶろぐ LIGHT11 Raspberlyのブログ PG日誌 やらなイカ？ Game Dev Beginner - Everyone Can Make Games LianBai (:3[kanのメモ帳] Unityゲーム開発者ギルド 老刘@开发笔记 はなちるのマイノート くものす Yucchiy&amp;rsquo;s Note Engineering Blog REALITY｜note Learning Unity Learning Materials Channel Unity Unity Japan Code Monkey M Studio Coco Code</description></item><item><title>Unity - 基礎</title><link>https://HoshikawaRyuukou.github.io/posts/unity-%E5%9F%BA%E7%A4%8E/</link><pubDate>Mon, 20 Feb 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-%E5%9F%BA%E7%A4%8E/</guid><description>Set Up 【游戏开发环境】Unity使用Mac电脑开发，开发环境的搭建（Mac mini M1 | VSCode | Git | 好用工具） Analysis Unity Optimize Your Game Using Profiler Unity 手機遊戲最佳化雜談– 內建Profiling Animation Introduction to 3D Animation Systems Audio Unity Audio Clip Import Settings For The Best Performance Audio tutorial for Unity: the Audio Mixer The right way to make a volume slider in Unity Build repositories.cfg could not be loaded. unity Camera Understanding Orthographic Size 探寻 Unity Camera 属性之 Clear Flags Unityの画面のアスペクト比と解像度を自動変換　全スマホ・複数解像度に対応させる Canvas Designing UI for Multiple Resolutions Unity Canvas Scaler 组件的使用 Unity分辨率适配方案设置 Editor 在unity编辑器不同位置添加菜单 SerializeReferenceをつけている型をリネーム・削除する時の注意点 What are EditorBuildSettings config objects used for or how can I use them?</description></item><item><title>架構設計 - Clean Architecture</title><link>https://HoshikawaRyuukou.github.io/posts/%E6%9E%B6%E6%A7%8B%E8%A8%AD%E8%A8%88-clean-architecture/</link><pubDate>Sat, 04 Feb 2023 20:03:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E6%9E%B6%E6%A7%8B%E8%A8%AD%E8%A8%88-clean-architecture/</guid><description>以下 Clean Architecture 簡稱 CA
這裡還是先引用 Uncle Bob 的分層圖 The Clean Code Blog - The Clean Architecture 筆者認爲可擴展性是系統架構的重要考量。畢竟應用程式會演化，必須不斷更新與修改系統以滿足新的需求，而 CA 是其中一種實現方針。筆者在這裡不會寫出詳細的介紹，想了解的可以參考 Ref 整理的連結或是 CA 相關書籍。
本文著重於促使筆者思考方式改變的幾個重要觀念。
依賴關係 相依性: 向內圈依賴，且盡量避免跨層依賴 (有些例外之後說明)。 Dependency Inversion Principle (DIP): 內圈定義介面，外圈實作。 基於這兩個規則所帶來的是
單向依賴流 : 紊亂的依賴流可能造成牽一髮動全身的窘境。尤其是當 Domain 去依賴到細節時。 延後實作 : UseCase/Adapter 都是依賴於應用層所開出的介面。因此業務/畫面能獨立開發，不用互相等待(理想狀態)。 而筆者在實作時的基本型架構通常如下圖(比較接近 CA 書中的另外一張圖，我這裡做了簡化)，Adapter 只分成 Input/Output Port。 Domain: 領域邏輯 UseCase: 應用邏輯 Domain + UseCase: 業務邏輯 InputPort: 用例功能使用方介面 OutputPort: 用例功能支援方介面 Adapter: 將外部與用例功能接合的膠水代碼 不過架構會針對不同情況做調整，細節參考另一篇文章
架構設計 - Clean Architecture and Modularization</description></item><item><title>Git - 筆記</title><link>https://HoshikawaRyuukou.github.io/posts/git-%E7%AD%86%E8%A8%98/</link><pubDate>Sat, 04 Feb 2023 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/git-%E7%AD%86%E8%A8%98/</guid><description>GUI Clients Fork Common 两小时Git教程 Git忽略规则.gitignore不生效 Workflow 如何做好分支管理，保证高效CI/CD？ 【GeekHour教程】分支管理和工作流模型 Git 進階應用 Submodule 與 Subtree，使用它們來拆分專案</description></item><item><title>Github - 筆記</title><link>https://HoshikawaRyuukou.github.io/posts/github-%E7%AD%86%E8%A8%98/</link><pubDate>Sat, 04 Feb 2023 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/github-%E7%AD%86%E8%A8%98/</guid><description>Profile 如何建立獨一無二的 GitHub Profile！與三個很酷的設計及應用 tandpfun/skill-icons</description></item><item><title>通用設計 - Guard Clauses</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-guard-clauses/</link><pubDate>Tue, 10 Jan 2023 21:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-guard-clauses/</guid><description>目的 符合 Fail Fast 的原則，驗證條件並在不滿足條件時立即停止執行。 增加可讀性(更扁平)，減少了巢狀判斷。 例子請參考 Guard Clause Extra - Guard Class 將通用的保護子句封裝在一個專門的類是一種很好的做法，可重用邏輯並編寫更具可讀性的保護子句。
可參考這個庫 GuardClauses Extra - Value Object Stop using trivial Guard Clauses! Try this instead
文章作者避免瑣碎 Guard 的方式，是使用 Value Object，來避免域接受到無效參數。這個作法在筆者看來才是真正意義上的 Fail Fast。(YT評論區也建議閱讀，有許多不錯的討論)
但不可否認的 Guard Clause 作法在大多情況下是有益的。
Ref Guard Clause Implementation Patterns: Guard Clause GuardClauses Stop using trivial Guard Clauses! Try this instead</description></item><item><title>C-Sharp - 筆記</title><link>https://HoshikawaRyuukou.github.io/posts/c-sharp-%E7%AD%86%E8%A8%98/</link><pubDate>Thu, 05 Jan 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/c-sharp-%E7%AD%86%E8%A8%98/</guid><description>語法 C# 的一些冷知识（其一） C# 的一些冷知识（其二） 捨棄 - C# 基本概念 C#中 ??、 ?、 ?: 、?.、? 问号 Type C# 4.0：Covariance 與 Contravariance 觀念入門 Data Different ways to return data in C# ValueTuple ValueTuple 是 value type，所以它使用的記憶體空間使用在 program stack，因此使用不會有 garbage collection
Format 內插字串 Collection C# 回傳內部資料集合的幾種方式，考慮封裝與設計需求 Iterate over two collections of equal length foreach (var (cell, id) in cells.Zip(randomizedIDs, (key, value) =&amp;gt; (Cell: key, ID: value))) { idDict[cell] = id; cell.selectCallback = Select; } Utils Random var random_list = list.</description></item><item><title>網路概論</title><link>https://HoshikawaRyuukou.github.io/posts/%E7%B6%B2%E8%B7%AF%E6%A6%82%E8%AB%96/</link><pubDate>Wed, 04 Jan 2023 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E7%B6%B2%E8%B7%AF%E6%A6%82%E8%AB%96/</guid><description> 【白话科普】域名？网址？原来域名是这么个玩意啊！ DNS工作原理 | 什么是DNS 它如何工作 CDN是什么 | CDN的工作机制</description></item><item><title>通用設計 - 設計原則</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87/</link><pubDate>Mon, 02 Jan 2023 21:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87/</guid><description>Library DevIQ Experiences Advice for junior developers Other The Last Responsible Moment DRY is about Knowledge</description></item><item><title>軟體設計 - Domain-Driven Design 初探</title><link>https://HoshikawaRyuukou.github.io/posts/%E8%BB%9F%E9%AB%94%E8%A8%AD%E8%A8%88-domain-driven-design-%E5%88%9D%E6%8E%A2/</link><pubDate>Thu, 15 Dec 2022 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E8%BB%9F%E9%AB%94%E8%A8%AD%E8%A8%88-domain-driven-design-%E5%88%9D%E6%8E%A2/</guid><description>必須先聲明筆者仍在學習中，以下屬個人觀點
動機 筆者發現在使用 Clean Architecture (CA) 時越來越力不從心，因此開始研究 Domain-Driven Design (DDD)，事出有因，列出幾點問題與對應方式。
重複的程式碼 主因是 貧血域模型 (Anemic Domain Model)，表示模型中幾乎只有 Get/Set，這導致了 Domain層 (業務邏輯) 滲透到 Application層 (應用邏輯)，某些對 Domain 的操作重複出現在多個的 Usecase (應用邏輯)。 重新分析系統，區分出不同上下文，設計充血域模型，將業務邏輯設計進去。 域模型的一致性問題 Domain 面對四面八方的操作，顯得很亂且充滿不確定(會不會模型之間的關係因為更改而被破壞) 引入聚合(Aggregate)來維持保護邊界內的不變條件。 Primitive Obsession 這會造成對模型的不信任，進而寫出一些防禦性程式設計。 引入值物件(Value Object)來確保不變性與自我驗證(即不正確就不應該存在)。 以上這幾點是筆者比較有感的。
概述與想法 Domain-Driven Design (DDD)，出自 Eric Evans 2003 年出版的一本書，以領域模型為中心來進行系統的分析設計。不是架構也不是技術，是一種方法論，可以搭配不同類型的架構來實現
Layered Architecture Hexagonal Architecture Clean Architecture (以下稱 CA ) Command Query Responsibility Segregation (CQRS) 原著中是使用 Layered Architecture 的架構作為示範，但該章的重點是在隔離 Domain，在 Google 的時候有所謂 &amp;ldquo;DDD 架構圖&amp;rdquo;，但筆者覺得不太精確，因為 DDD 主要的發力點是在 Domain，應該稱作 &amp;ldquo;OO架構以DDD實作Domain&amp;rdquo; 會比較合適。</description></item><item><title>通用設計 - Data Transfer Object (DTO)</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-data-transfer-object-dto/</link><pubDate>Sun, 11 Dec 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-data-transfer-object-dto/</guid><description>什麼是 DTO？ Data Transfer Object (數據傳輸對象) 是定義如何在應用程序之間發送數據的對象。它僅用於發送和接收數據，本身不包含任何邏輯。
為什麼使用 DTO？ 輕鬆收發 在沒有任何邏輯的基礎上，可以僅使用序列化與反序列化就保證對象的完整性和可傳遞性。
避免過度暴露訊息 對分層或模組來說，彼此間應盡量降低耦合。下圖以公園廁所報修為案例。
這個資料流由鄉公所傳到基層人員手上，中間經過兩個邊界
鄉公所 | 工程公司 =&amp;gt; DTO (公文) 工程公司 | 基層人員 =&amp;gt; DTO (簡訊) 每個單位的關注點不同，在意的資料也會不同，DTO 做為邊界兩方做最小程度的媒介，隱藏的不該被關注(敏感)的事
印章對工程公司並不是必要資訊 詳細的時間格式是對基層人員並不是必要資訊 在實作上常被用於轉換 DomainModol -&amp;gt; DomainDto
注意事項 類別數量增加，請自行評估使用情形
Ref Cutting Edge - Pros and Cons of Data Transfer Objects The DTO (Data Transfer Object) Data Transfer Objects Clean Architecture : why not using the entity as request model of the use case (interactor) Difference between Entity and DTO</description></item><item><title>通用設計 - Pattern - MVP</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-pattern-mvp/</link><pubDate>Sat, 10 Dec 2022 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-pattern-mvp/</guid><description>前述 關注點分離（Separation of Concerns，SoC）: 在軟體開發中，一個模組或組件應該專注於解決特定的問題，而不是同時處理多個功能。每個組件都有自己的職責範圍，並且與其他組件盡可能解耦合。
而 MVC / MVP / MVVM 是關注點分離於前端的經典應用，網上已經有很多不錯的文章，再寫一份類似的整理文章意義也不大，對此感到陌生，不妨閱讀以下連結，會幫助你理解 MV系列的發展。
界面之下：还原真实的MV*模式 正确认识 MVC/MVP/MVVM 站在思想层面看MVX架构 MVP Pattern: Part 2 Supervising Controller Part 2 — Converting Presenters into ViewModels 以下則對筆者實作中比較常用的 MVP 多做一些討論
關注點(責任) 在 MVP 的構成下分成三個部分
Model: 應用程式的核心邏輯。 View: 應用程式的使用者介面，負責呈現數據和接收使用者的輸入。 Presenter: View 和 Model 之間的中介。 Passive View 這是 MVP 的一種實作風格，也是筆者主要使用的風格。
Presenter 對 View 有完全控制權 View 提供方法與事件給 Presenter 使用 View 對 Presenter 一無所知 以猜拳遊戲的 View 為例
public class View : MonoBehaviour { [SerializeField] private Text messageText; [SerializeField] private Button[] playerChoices; [SerializeField] private Button nextButton; private readonly Subject&amp;lt;Choice&amp;gt; playerChoiceSelected = new Subject&amp;lt;Choice&amp;gt;(); private readonly CompositeDisposable disposables = new CompositeDisposable(); public IObservable&amp;lt;Choice&amp;gt; PlayerChoiceSelected =&amp;gt; playerChoiceSelected; public IObservable&amp;lt;Unit&amp;gt; PlayerNextRequested =&amp;gt; nextButton.</description></item><item><title>Assets - 素材</title><link>https://HoshikawaRyuukou.github.io/posts/assets-%E7%B4%A0%E6%9D%90/</link><pubDate>Tue, 22 Nov 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/assets-%E7%B4%A0%E6%9D%90/</guid><description>Color Coolors Palettable Icon ICOOON MONO iconmonstr Flaticon IconKitchen Game-icons.net Feature Graphics Google Play Feature Graphics Font 中文免費字體 Google Fonts Audio 魔王魂 効果音ラボ フリーBGM（音楽素材）無料ダウンロード｜DOVA-SYNDROME フリー効果音素材・無料効果音 Image Unsplash Image API | Free HD Photo API Lorem Picsum Photosku 2023 熱門 47 個可商用無版權免費圖庫懶人包（圖片、圖示、圖標、素材、背景） Textures Poly Haven 背景 OKUMONO Misc Opengameart Kenney かわいいフリー素材集 いらすとや Repo itch.io Info 網路資源列表| DeTools</description></item><item><title>輔助工具</title><link>https://HoshikawaRyuukou.github.io/posts/%E8%BC%94%E5%8A%A9%E5%B7%A5%E5%85%B7-%E7%B8%BD%E8%A6%BD/</link><pubDate>Sun, 20 Nov 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E8%BC%94%E5%8A%A9%E5%B7%A5%E5%85%B7-%E7%B8%BD%E8%A6%BD/</guid><description>網站 史上最簡單「一頁式網站」建置工具！ | Google Sites 協作平台快速上手 製圖 只會用 Office 畫流程圖？許多人試用過這個後直呼回不去了 👍 | Draw.io 教學 Code Image</description></item><item><title>通用設計 - Navigation</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-navigation/</link><pubDate>Wed, 16 Nov 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-navigation/</guid><description>以下 Feature 指的是一個功能獨立的模組，Feature A 將簡稱 A。
問題 應用程式中有一個由 A 到 B 的導航，那這個導航是誰的責任?
以下先討論 2 種狀況。
A 直接依賴 B 簡單粗暴的強耦合破壞了 A 的獨立性。當流程發生變化時，可能需要到各個 Feature 去修改。
Feature A -&amp;gt; Feature B A 引入導航器間接依賴 B 這作法將導航操作收斂到某個類中，但 A 仍然隱含的知道 B，這同樣破壞了 A 的獨立性。
Feature A -&amp;gt; INavigator.Route(View.FeatureB) // Enum or Feature A -&amp;gt; INavigator.Route(&amp;#34;FeatureB&amp;#34;) // 魔術字串 or Feature A -&amp;gt; INavigator.RouteFeatureB() 重新思考導航這件事
Feature 應該知道自己是能夠 被導航 或是 能導航到哪 嗎? 到底 A 能導航到 B 這件事是誰決定的? 應該隱約地感覺到了吧，導航並不屬於 A 也不屬於 B，導航是一個獨立操作，需要一個額外的單位來負責。此外這個單位多是屬於 App 級別的(因為該層級有對其他模組的正當訪問性，畢竟是負責做統合的)。</description></item><item><title>通用設計 - Dependency Inversion Principle (DIP)</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-dependency-inversion-principle-dip/</link><pubDate>Tue, 15 Nov 2022 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-dependency-inversion-principle-dip/</guid><description>依賴倒置原則 Dependency Inversion Principle，以下皆簡稱 DIP。
為什麼需要 先來看定義
高層次的模塊不應該依賴於低層次的模塊，兩者都應該依賴於抽象接口 抽象接口不應該依賴於具體實現。而具體實現則應該依賴於抽象接口 文謅謅的，但重點似乎是抽象。不如直接看個狀況劇:
有一個 Project A 需要使用播廣告的功能。分別採 2 個做法
直接依賴 直覺的做法。Project A 直接依賴於廣告模組(UnityAds)，這裡模組 Project A 被迫去了解 UnityAds 的實作細節(怎麼初始化/下載廣告/播廣告)。
目前沒甚麼問題，運作得很好&amp;hellip; 但很快問題就來了。UnityAds 因為某些原因不能用了! (假設後臺被打了什麼的)。於是找了另一個廣告模組(AdMob)，想要如法炮製，但有幾點可能會不好受。
要改的地方很分散 (廣告被 Project A 多處使用) Project A 需要處理不同的 API格式 (了解細節，單例、Callback、事件&amp;hellip;) 導致原先依賴 UnityAds 的模組需要重新編譯 (造成浪費時間) 原因是直接依賴外部模組導致的，相對於你的系統 UnityAds 是個外人，是不穩定的，去依賴一個不穩定的東西，也會導致自己變得不穩定。
依賴倒置 仔細想一下，Project A 直接依賴 UnityAds 是必要的嗎? 需求是播 UnityAds 的廣告? 還是播廣告? 為了實現穩定廣告服務的依賴源，我們將其抽象化
public interface IAdService { void Initialize(); void Load(); void Show(); } 但 UnityAds 與 AdMob 又不能直接實作這個介面怎麼辦，可以用配接器模式(Adapter Pattern)寫個轉接頭，想辦法讓外部細節符合 IAdService 的需求。現在需要廣告服務的部分均透過 IAdService來操作，不需再知道外部廣告模組的細節。</description></item><item><title>網路設計 - RPC</title><link>https://HoshikawaRyuukou.github.io/posts/%E7%B6%B2%E8%B7%AF%E8%A8%AD%E8%A8%88-rpc/</link><pubDate>Mon, 07 Nov 2022 21:06:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E7%B6%B2%E8%B7%AF%E8%A8%AD%E8%A8%88-rpc/</guid><description>RPC (Remote Procedure Call，遠端程序呼叫) 是一種通信協定，多用於分佈式系統的通信。
目的 讓客戶端呼叫遠程函式就像呼叫本地函式一樣。將網路通信封裝成函式來使用，那麼客戶端將不需要關心網路協定/模型。
流程 client 客戶端通過本地呼叫的方式呼叫服務 client stub 接收到請求後將參數序列化成能夠進行網路傳輸的訊息體 client stub 找到服務地址，並將訊息發送給服務端 server stub 收到訊息後進行反序列化 server stub 根據反序列化結果呼叫本地服務 本地服務執行並將處理結果返回給 server stub server stub 將結果序列化並發送至 client stub client stub 接收到訊息，並進行反序列化 client 得到最終結果 Ref 怎么理解rpc，既然有http请求了为啥还要用rpc？ 谁能用通俗的语言解释一下什么是 RPC 框架？</description></item><item><title>哲學問題 - 忒修斯之船 (Ship of Theseus)</title><link>https://HoshikawaRyuukou.github.io/posts/%E5%93%B2%E5%AD%B8%E5%95%8F%E9%A1%8C-%E5%BF%92%E4%BF%AE%E6%96%AF%E4%B9%8B%E8%88%B9-ship-of-theseus/</link><pubDate>Sun, 06 Nov 2022 21:20:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E5%93%B2%E5%AD%B8%E5%95%8F%E9%A1%8C-%E5%BF%92%E4%BF%AE%E6%96%AF%E4%B9%8B%E8%88%B9-ship-of-theseus/</guid><description>問題 1世紀時的希臘作家普魯塔克問到
如果忒修斯的船上的木頭逐漸被替換，直到所有的木頭都不是原來的木頭，那這艘船還是原來的那艘船嗎？
思考 這艘船在被賦予存在意義之前，就不過是一堆木頭與金屬，如果沒有使用他的人，那麼船將沒有他的意義。因此只要賦予它存在意義的人還在，或者說這份存在意義能夠被繼承下去，無論它變成什麼樣子，它還是那艘船。</description></item><item><title>你好! Hugo</title><link>https://HoshikawaRyuukou.github.io/posts/%E4%BD%A0%E5%A5%BD-hugo/</link><pubDate>Sat, 05 Nov 2022 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E4%BD%A0%E5%A5%BD-hugo/</guid><description>Blog 起初筆者覺得使用 Github Repository + Markdown 當作筆記就足矣。但隨著筆記越多越雜，只使用文件夾結構 + 目錄超連結，在查找上越覺得不便，還是需要有一套系統來代勞。Blog/筆記 平台玲瑯滿目，但寄身於平台的風險難以忽視(倒站/政策改變)，網站搬家也讓人很頭疼。之前就知道靜態網站能架在 Github 上，只是一直沒研究，剛好趁這個機會練習一下 Web 前端的技能。最後的方案是 Github Pages + Hugo。
Hugo 網上的教學也很多，筆者先是快速瀏覽一下幾篇文章再動工，這裡就不手把手介紹，這主要記錄一些筆者遇到的坑。
Hugo 貼身打造個人部落格系列 網站開張！在 GitHub Pages 架設 Hugo 靜態網站 開始 官方的文件 Official Doc 已經足夠清楚了，照著 Quick Start 跑完就有一個完整的畫面(以靜態網站來說)，但這裡有幾個注意的點。
使用 Binary (Cross-platform) 配置 Hugo 時，有 hugo / hugo_extended 版本，且要手動配置環境變數。extended 支援 Sass/SCSS，這裡沒注意到花了不少時間，想說改個主題佈局怎麼編譯不過，Hugo Discourse Support。 設置 .gitignore 主題 主題有很多選擇 Official Link / Github Tag - hugo-theme，有的已經打磨得很完善。筆者對這個 Blog 希望以簡潔明快為主，紀錄是第一要務。最終採用這個 Theme - Cactus (變心可換問題不大)，之後肯定會進行一些魔改的，不然自架的意義就小很多了。
選擇上幾點注意
避開一些太舊的主題 (跟 Hugo 衝突 / js腳本過舊&amp;hellip;) 第三方 API 遇到大改動時要排除一下才能建置 ( FB / IG 讓好多主題要改&amp;hellip;) 修改上幾點注意</description></item><item><title>About me</title><link>https://HoshikawaRyuukou.github.io/about/</link><pubDate>Wed, 24 Aug 2016 17:51:42 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/about/</guid><description>Github: HoshikawaRyuukou</description></item></channel></rss>