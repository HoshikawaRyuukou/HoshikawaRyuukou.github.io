<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>識之箱庭</title><link>https://HoshikawaRyuukou.github.io/</link><description>Recent content on 識之箱庭</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>HoshikawaRyuukou</copyright><lastBuildDate>Thu, 15 Dec 2022 20:05:00 +0000</lastBuildDate><atom:link href="https://HoshikawaRyuukou.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>軟體設計 - Domain-Driven Design - Unit Test</title><link>https://HoshikawaRyuukou.github.io/posts/%E8%BB%9F%E9%AB%94%E8%A8%AD%E8%A8%88-domain-driven-design-unit-test/</link><pubDate>Thu, 15 Dec 2022 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E8%BB%9F%E9%AB%94%E8%A8%AD%E8%A8%88-domain-driven-design-unit-test/</guid><description>Ref Domain-Driven Design &amp;amp; Unit Tests</description></item><item><title>軟體設計 - Domain-Driven Design - 初探</title><link>https://HoshikawaRyuukou.github.io/posts/%E8%BB%9F%E9%AB%94%E8%A8%AD%E8%A8%88-domain-driven-design-%E5%88%9D%E6%8E%A2/</link><pubDate>Thu, 15 Dec 2022 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E8%BB%9F%E9%AB%94%E8%A8%AD%E8%A8%88-domain-driven-design-%E5%88%9D%E6%8E%A2/</guid><description>必須先聲明筆者仍在學習中，以下屬個人觀點
動機 筆者發現在使用 Clean Architecture (CA) 時越來越力不從心，因此開始研究 Domain-Driven Design (DDD)，事出有因，列出幾點問題與對應方式。
重複的程式碼 主因是 貧血域模型 (Anemic Domain Model)，表示模型中幾乎只有 Get/Set，這導致了 Domain層 (業務邏輯) 滲透到 Application層 (應用邏輯)，某些對 Domain 的操作重複出現在多個的 Usecase (應用邏輯)。 重新分析系統，區分出不同上下文，設計充血域模型，將業務邏輯設計進去。 域模型的一致性問題 Domain 面對四面八方的操作，顯得很亂且充滿不確定(會不會模型之間的關係因為更改而被破壞) 引入聚合(Aggregate)來維持保護邊界內的不變條件。 Primitive Obsession 這會造成對模型的不信任，進而寫出一些防禦性程式設計。 引入值物件(Value Object)來確保不變性與自我驗證(即不正確就不應該存在)。 以上這幾點是筆者比較有感的。
概述與想法 Domain-Driven Design (DDD)，出自 Eric Evans 2003 年出版的一本書，以領域模型為中心來進行系統的分析設計。不是架構也不是技術，是一種方法論，可以搭配不同類型的架構來實現
Layered Architecture Hexagonal Architecture Clean Architecture (以下稱 CA ) Command Query Responsibility Segregation (CQRS) 原著中是使用 Layered Architecture 的架構作為示範，但該章的重點是在隔離 Domain，在 Google 的時候有所謂 &amp;ldquo;DDD 架構圖&amp;rdquo;，但筆者覺得不太精確，因為 DDD 主要的發力點是在 Domain，應該稱作 &amp;ldquo;OO架構以DDD實作Domain&amp;rdquo; 會比較合適。</description></item><item><title>Asset - 素材</title><link>https://HoshikawaRyuukou.github.io/posts/asset-%E7%B4%A0%E6%9D%90/</link><pubDate>Tue, 22 Nov 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/asset-%E7%B4%A0%E6%9D%90/</guid><description>Color Coolors Palettable Icon ICOOON MONO iconmonstr Font 中文免費字體 Audio 魔王魂 Image Unsplash Image API | Free HD Photo API</description></item><item><title>Sites - UI-UX</title><link>https://HoshikawaRyuukou.github.io/posts/sites-ui-ux/</link><pubDate>Sun, 20 Nov 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/sites-ui-ux/</guid><description>個人 ゲームUI演出 | このサイト(ゲームUI演出)はアニメーションデザイナー用に管理人がUIアニメーションについてつらつら書くサイトです。 -動くWebデザインアイディア帳</description></item><item><title>Sites - 開發</title><link>https://HoshikawaRyuukou.github.io/posts/sites-%E9%96%8B%E7%99%BC/</link><pubDate>Sun, 20 Nov 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/sites-%E9%96%8B%E7%99%BC/</guid><description>企業 Sumzap Engineering Blog 個人 (Unity) 渋谷ほととぎす通信 きゅぶろぐ LIGHT11</description></item><item><title>Tests - Unit Test</title><link>https://HoshikawaRyuukou.github.io/posts/tests-unit-test/</link><pubDate>Sat, 12 Nov 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/tests-unit-test/</guid><description>Doc NUnit Ref .NET Core 和 .NET Standard 的單元測試最佳做法 [Day 2]Unit Testing 簡介 NUnit 幾個參數化測試的方式</description></item><item><title>Unity - Packages</title><link>https://HoshikawaRyuukou.github.io/posts/unity-packages/</link><pubDate>Sat, 12 Nov 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-packages/</guid><description>Package Manager Installing Packages using UPM Package manager -&amp;gt; Advanced project settings Add Scoped Registries Name: package.openupm.com URL: https://package.openupm.com Scope(s): com.cysharp.unitask Package manager -&amp;gt; Packages: My Registries -&amp;gt; Install Dependency Injection VContainer
openupm - jp.hadashikick.vcontainer
P.S. How to avoid Dependency Injection constructor madness? Rx (Reactive Extensions) UniRx openupm - com.neuecc.unirx Async UniTask openupm - com.cysharp.unitask Messaging MessagePipe openupm - com.cysharp.messagepipe
MagicOnion</description></item><item><title>Unity - Unit Test</title><link>https://HoshikawaRyuukou.github.io/posts/unity-unit-test/</link><pubDate>Sat, 12 Nov 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-unit-test/</guid><description> Doing basic unit testing in Unity/C#</description></item><item><title>初探 RPC</title><link>https://HoshikawaRyuukou.github.io/posts/rpc-%E5%88%9D%E6%8E%A2/</link><pubDate>Mon, 07 Nov 2022 21:06:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/rpc-%E5%88%9D%E6%8E%A2/</guid><description>RPC (Remote Procedure Call，遠端程序呼叫) 是一種通信協定，多用於分佈式系統的通信。
目的 讓客戶端呼叫遠程函式就像呼叫本地函式一樣。將網路通信封裝成函式來使用，那麼客戶端將不需要關心網路協定/模型。
流程 client 客戶端通過本地呼叫的方式呼叫服務 client stub 接收到請求後將參數序列化成能夠進行網路傳輸的訊息體 client stub 找到服務地址，並將訊息發送給服務端 server stub 收到訊息後進行反序列化 server stub 根據反序列化結果呼叫本地服務 本地服務執行並將處理結果返回給 server stub server stub 將結果序列化並發送至 client stub client stub 接收到訊息，並進行反序列化 client 得到最終結果 參考 怎么理解rpc，既然有http请求了为啥还要用rpc？ 谁能用通俗的语言解释一下什么是 RPC 框架？</description></item><item><title>忒修斯之船</title><link>https://HoshikawaRyuukou.github.io/posts/%E5%BF%92%E4%BF%AE%E6%96%AF%E4%B9%8B%E8%88%B9/</link><pubDate>Sun, 06 Nov 2022 21:20:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E5%BF%92%E4%BF%AE%E6%96%AF%E4%B9%8B%E8%88%B9/</guid><description>忒修斯之船（Ship of Theseus） 問題 1世紀時的希臘作家普魯塔克問到
如果忒修斯的船上的木頭逐漸被替換，直到所有的木頭都不是原來的木頭，那這艘船還是原來的那艘船嗎？
思考 這艘船在被賦予存在意義之前，就不過是一堆木頭與金屬，如果沒有使用他的人，那麼船將沒有他的意義。因此只要賦予它存在意義的人還在，或者說這份存在意義能夠被繼承下去，無論它變成什麼樣子，它還是那艘船。</description></item><item><title>你好! Hugo</title><link>https://HoshikawaRyuukou.github.io/posts/%E4%BD%A0%E5%A5%BD-hugo/</link><pubDate>Sat, 05 Nov 2022 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E4%BD%A0%E5%A5%BD-hugo/</guid><description>Blog 起初筆者覺得使用 Github Repository + Markdown 當作筆記就足矣。但隨著筆記越多越雜，只使用文件夾結構 + 目錄超連結，在查找上越覺得不便，還是需要有一套系統來代勞。Blog/筆記 平台玲瑯滿目，但寄身於平台的風險難以忽視(倒站/政策改變)，網站搬家也讓人很頭疼。之前就知道靜態網站能架在 Github 上，只是一直沒研究，剛好趁這個機會練習一下 Web 前端的技能。最後的方案是 Github Pages + Hugo。
Hugo 網上的教學也很多，筆者先是快速瀏覽一下幾篇文章再動工，這裡就不手把手介紹，這主要記錄一些筆者遇到的坑。
Hugo 貼身打造個人部落格系列 網站開張！在 GitHub Pages 架設 Hugo 靜態網站 開始 官方的文件 Official Doc 已經足夠清楚了，照著 Quick Start 跑完就有一個完整的畫面(以靜態網站來說)，但這裡有幾個注意的點。
使用 Binary (Cross-platform) 配置 Hugo 時，有 hugo / hugo_extended 版本，且要手動配置環境變數。extended 支援 Sass/SCSS，這裡沒注意到花了不少時間，想說改個主題佈局怎麼編譯不過，Hugo Discourse Support。 設置 .gitignore 主題 主題有很多選擇 Official Link / Github Tag - hugo-theme，有的已經打磨得很完善。筆者對這個 Blog 希望以簡潔明快為主，紀錄是第一要務。最終採用這個 Theme - Cactus (變心可換問題不大)，之後肯定會進行一些魔改的，不然自架的意義就小很多了。
選擇上幾點注意
避開一些太舊的主題 (跟 Hugo 衝突 / js腳本過舊&amp;hellip;) 第三方 API 遇到大改動時要排除一下才能建置 ( FB / IG 讓好多主題要改&amp;hellip;) 修改上幾點注意</description></item><item><title>About me</title><link>https://HoshikawaRyuukou.github.io/about/</link><pubDate>Wed, 24 Aug 2016 17:51:42 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/about/</guid><description>Github: HoshikawaRyuukou</description></item></channel></rss>