<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Architecture on 識之箱庭</title><link>https://HoshikawaRyuukou.github.io/tags/architecture/</link><description>Recent content in Architecture on 識之箱庭</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>HoshikawaRyuukou</copyright><lastBuildDate>Wed, 22 Feb 2023 21:21:00 +0000</lastBuildDate><atom:link href="https://HoshikawaRyuukou.github.io/tags/architecture/index.xml" rel="self" type="application/rss+xml"/><item><title>通用設計 - Architecture - Modularization</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-architecture-modularization/</link><pubDate>Wed, 22 Feb 2023 21:21:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-architecture-modularization/</guid><description>前述 首先幾篇文章是基於 Clean Architecture 的基礎，建議先閱讀以下連結已具備基礎知識
The missing chapter CA 原著 Chapter 34 - The missing chapter - Actual implementation details of an architecture 連結 34章摘要心得，請先觀看裡面的圖表(重要) CA Modularization Multiple ways of defining Clean Architecture layers Package by Component with Clean Modules in Java Package by feature or component Vertical Slice Slices vs. Layers Restructuring to a Vertical Slice Architecture Vertical Slice Architecture, not Layers! Modular Monolith Majestic Modular Monoliths (強烈建議) Modular Monolith architecture (強烈建議讀完這個系列) 各 Package 策略的圖請參考上方連結 34 章摘要心得</description></item><item><title>通用設計 - Architecture - Clean Architecture</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-architecture-clean-architecture/</link><pubDate>Sat, 04 Feb 2023 20:03:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-architecture-clean-architecture/</guid><description>以下 Clean Architecture 簡稱 CA
這裡還是先引用 Uncle Bob 的分層圖 The Clean Code Blog - The Clean Architecture 筆者認爲可擴展性是系統架構的重要考量。畢竟應用程式會演化，必須不斷更新與修改系統以滿足新的需求，而 CA 是其中一種實現方針。筆者在這裡不會寫出詳細的介紹，想了解的可以參考 Ref 整理的連結或是 CA 相關書籍。
本文著重於促使筆者思考方式改變的幾個重要觀念。
依賴關係 相依性: 向內圈依賴，且盡量避免跨層依賴 (有些例外之後說明)。 Dependency Inversion Principle (DIP): 內圈定義介面，外圈實作。 基於這兩個規則所帶來的是
單向依賴流 : 紊亂的依賴流可能造成牽一髮動全身的窘境。尤其是當 Domain 去依賴到細節時。 延後實作 : UseCase/Adapter 都是依賴於應用層所開出的介面。因此業務/畫面能獨立開發，不用互相等待(理想狀態)。 而筆者在實作時的基本型架構通常如下圖(比較接近 CA 書中的另外一張圖，我這裡做了簡化)，Adapter 只分成 Input/Output Port。 Domain: 領域邏輯 UseCase: 應用邏輯 Domain + UseCase: 業務邏輯 InputPort: 用例功能使用方介面 OutputPort: 用例功能支援方介面 Adapter: 將外部與用例功能接合的膠水代碼 不過架構會針對不同情況做調整，細節參考另一篇文章
架構設計 - Clean Architecture and Modularization</description></item><item><title>通用設計 - Architecture - Navigation</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-architecture-navigation/</link><pubDate>Wed, 16 Nov 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-architecture-navigation/</guid><description>以下 Feature 指的是一個功能獨立的模組，Feature A 將簡稱 A。
問題 應用程式中有一個由 A 到 B 的導航，那這個導航是誰的責任?
以下先討論 2 種狀況。
A 直接依賴 B 簡單粗暴的強耦合破壞了 A 的獨立性。當流程發生變化時，可能需要到各個 Feature 去修改。
Feature A -&amp;gt; Feature B A 引入導航器間接依賴 B 這作法將導航操作收斂到某個類中，但 A 仍然隱含的知道 B，這同樣破壞了 A 的獨立性。
Feature A -&amp;gt; INavigator.Route(View.FeatureB) // Enum or Feature A -&amp;gt; INavigator.Route(&amp;#34;FeatureB&amp;#34;) // 魔術字串 or Feature A -&amp;gt; INavigator.RouteFeatureB() 重新思考導航這件事
Feature 應該知道自己是能夠 被導航 或是 能導航到哪 嗎? 到底 A 能導航到 B 這件事是誰決定的? 應該隱約地感覺到了吧，導航並不屬於 A 也不屬於 B，導航是一個獨立操作，需要一個額外的單位來負責。此外這個單位多是屬於 App 級別的(因為該層級有對其他模組的正當訪問性，畢竟是負責做統合的)。</description></item></channel></rss>