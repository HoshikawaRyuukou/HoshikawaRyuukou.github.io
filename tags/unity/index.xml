<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Unity on 識之箱庭</title><link>https://HoshikawaRyuukou.github.io/tags/unity/</link><description>Recent content in Unity on 識之箱庭</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>HoshikawaRyuukou</copyright><lastBuildDate>Wed, 08 Nov 2023 21:11:00 +0000</lastBuildDate><atom:link href="https://HoshikawaRyuukou.github.io/tags/unity/index.xml" rel="self" type="application/rss+xml"/><item><title>Unity - External Dependency Manager for Unity (EDM4U)</title><link>https://HoshikawaRyuukou.github.io/posts/unity-external-dependency-manager-for-unity-edm4u/</link><pubDate>Wed, 08 Nov 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-external-dependency-manager-for-unity-edm4u/</guid><description>前言 Google 停止維護 Game Package Registry (GPR) 導致不能直接使用 Package Manager 導入包。必須到封存檔網站下載「.tgz」手動導入。
Google Unity 套件 Install a package from a local tarball file 其他的相關的 Google Service 依賴(AR/Firebase/Google Play等)也可以用此方法導入。
設定 Assets → External Dependency Manager → Android Resolver → Settings，啟用這三個 Patch 並至 Player Settings → Publishing Settings 啟用以下選項</description></item><item><title>Unity - Basic - Asset Management</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-asset-management/</link><pubDate>Sat, 09 Sep 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-asset-management/</guid><description>AssetBundle Assets, Resources and AssetBundles Case Studies of Unity AssetBundle Efficient Encryption Frameworks Addressables Addressables YooAsset tuyoogame/YooAsset</description></item><item><title>Unity - Packages</title><link>https://HoshikawaRyuukou.github.io/posts/unity-packages/</link><pubDate>Thu, 03 Aug 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-packages/</guid><description>Package Manager Installing Packages using UPM Package manager -&amp;gt; Advanced project settings Add Scoped Registries Name: package.openupm.com URL: https://package.openupm.com Scope(s): com.cysharp.unitask Package manager -&amp;gt; Packages: My Registries -&amp;gt; Install Unity中 .asmdef文件的作用 使用OpenUPM发布自己的Unity项目 开发Unity PackageManager 插件包 Creating Custom Packages for Unity 2018.3 How to remodel your project for asmdef and UPM Animation DOTween Link Async UniTask openupm - com.cysharp.unitask Patterns &amp;amp; Practices for efficiently handling C# async/await cancel processing and timeouts 精选Unity-Github开源库分享 最完美的异步操作解决方案 UniTask C# Task 指南 async/await,disposableを使って素直で読みやすいコードを書く UniTaskCompletionSource Should Support CancellationToken Debug UnityIngameDebugConsole openupm - com.</description></item><item><title>Unity - Basic - Memory Profiler</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-memory-profiler/</link><pubDate>Sun, 30 Jul 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-memory-profiler/</guid><description>注意 由於Unity 無法將性能分析器本身佔用的記憶體與運行模式的記憶體完全分開。要獲得應用程序的更精確數字和記憶體使用情況，應在要運行應用程序的目標設備和操作系統上分析應用程序。 如果需要在記憶體受限的平台上運行應用程序，設備上的總駐留量對於檢查低記憶體警告和由於記憶體耗盡而強制關閉非常有用。作為一般規則，它不應超過設備上可用總物理內存的 70%。 偵測 Leaked Managed Shell 的功能在 Memory Profiler 1.1.0-pre.1 Ref Memory Profiler Memory Profiler | 1.1.0-pre.1 - Unity - Manual Unity でメモリリーク？ Memory Profiler で Leaked Managed Shell をチェックしてみよう！ Inspecting memory with the new Memory Profiler package Memory Profiler로 애플리케이션의 물리적 메모리 사용량 분석 Unity内存分析与优化实践(1.1版本前)</description></item><item><title>C-Sharp - Basic - 前置處理器指示詞</title><link>https://HoshikawaRyuukou.github.io/posts/c-sharp-basic-%E5%89%8D%E7%BD%AE%E8%99%95%E7%90%86%E5%99%A8%E6%8C%87%E7%A4%BA%E8%A9%9E/</link><pubDate>Fri, 07 Jul 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/c-sharp-basic-%E5%89%8D%E7%BD%AE%E8%99%95%E7%90%86%E5%99%A8%E6%8C%87%E7%A4%BA%E8%A9%9E/</guid><description>前述 筆者最近接觸到的遺舊專案中發現裡面大量地使用 條件式編譯
#if DEBUG Console.WriteLine(&amp;#34;Debug version&amp;#34;); #endif 筆者之前有使用也基本只使用 定義區域 (排版效果)
#region MyClass definition public class MyClass { static void Main(){...} } #endregion Unity 在處理平台裝置時也蠻常會出現的
public class PlatformDefines : MonoBehaviour { void Start () { #if UNITY_EDITOR Debug.Log(&amp;#34;Unity Editor&amp;#34;); #endif #if UNITY_IOS Debug.Log(&amp;#34;iOS&amp;#34;); #endif #if UNITY_STANDALONE_OSX Debug.Log(&amp;#34;Standalone OSX&amp;#34;); #endif #if UNITY_STANDALONE_WIN Debug.Log(&amp;#34;Standalone Windows&amp;#34;); #endif } } 問題 那前置處理器指示詞有什麼問題呢? (參考日文那個 Ref 有比較明確的 Case)
編譯版本至少會是 2^(指示詞的分類數)種，持續的調試和測試變得非常困難。 Unit Test 中難以使用。 編譯檢查不起作用。 當巢狀結構出現時可讀性將大為降低。 上述這些狀況都會導致 延後發現問題的時間 !</description></item><item><title>Unity - Basic - iOS plug-in</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-ios-plug-in/</link><pubDate>Wed, 05 Jul 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-ios-plug-in/</guid><description>前述 這次的業務需求是
取得 ios 實機的 &amp;ldquo;地區&amp;rdquo;，並讓 C# 能拿到 Swift 所返回的字串
因為在 ios 的環境下 unity / C# 拿到的值並不正確。此外筆者對 Swift / Objective-C 幾乎零基礎，目前只針對一些教學文件做些修改，之後有機會更熟再回頭深究。
實作 SwiftDeviceInfoPlugin.swift 須放置於 Plugins\iOS 之下 import Foundation public class SwiftDeviceInfoPlugin { public static func getRegion() -&amp;gt; String { return Locale.current.regionCode ?? &amp;#34;Unknown&amp;#34; } } @_cdecl(&amp;#34;getRegion&amp;#34;) public func getRegion() -&amp;gt; UnsafePointer&amp;lt;CChar&amp;gt;? { let region = strdup(SwiftDeviceInfoPlugin.getRegion()) return UnsafePointer(region) } @_cdecl(&amp;ldquo;getRegion&amp;rdquo;)：這是一個 Swift 標記，表示下面的函數將使用cdecl樣式的名稱綁定。您只需知道此屬性向 C 公開了一個 Swift 函數 UnsafePointer&amp;lt;CChar&amp;gt;?，它是一個可為空的指向 C 風格字串（CChar）的指標。這使得 Swift 能夠以與 C 相容的方式提供訪問區域資訊的介面。 strdup() 用於創建預返回的字串的副本，並在堆上分配其記憶體。 public sealed class IOSDeviceInfoProvider : IDeviceInfoProvider { public string GetRegion() { return new System.</description></item><item><title>Unity - Package - xLua</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-xlua/</link><pubDate>Sun, 28 May 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-xlua/</guid><description>本次操作 xLua 主要是做熱更方案的評估測試，筆者目前還是偏好使用 HybridCLR。
Official Tencent/xLua 評估 使用 lua 仍是目前主流/穩定做法 (畢竟也行之有年了)。 邏輯操作可能要移師到 lua 側。 缺少 ide 支援如果要在 lua 側 進行 unity 相關操作時，維護/除錯成本極高。 Example 在 lua 側進行 unity 相關操作
local speed = 10 local lightCpnt = nil function start() print(&amp;#34;lua start...&amp;#34;) print(&amp;#34;injected object&amp;#34;, lightObject) lightCpnt= lightObject:GetComponent(typeof(CS.UnityEngine.Light)) end function update() local r = CS.UnityEngine.Vector3.up * CS.UnityEngine.Time.deltaTime * speed self.transform:Rotate(r) lightCpnt.color = CS.UnityEngine.Color(CS.UnityEngine.Mathf.Sin(CS.UnityEngine.Time.time) / 2 + 0.5, 0, 0, 1) end function ondestroy() print(&amp;#34;lua destroy&amp;#34;) end</description></item><item><title>Unity - Editor - ScriptedImporter</title><link>https://HoshikawaRyuukou.github.io/posts/unity-editor-scriptedimporter/</link><pubDate>Sat, 27 May 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-editor-scriptedimporter/</guid><description>用途 使用C# 為Unity 本身不支持的文件格式編寫自定義資源導入器，從而添加支持。 注意 Scripted Importer 無法處理已由 Unity 本身處理的文件擴展名。 Example 這裡將 .lua 以 TextAsset
using UnityEngine; using System.IO; using UnityEditor.AssetImporters; [ScriptedImporter( 1, &amp;#34;lua&amp;#34; )] public class LuaImporter : ScriptedImporter { public override void OnImportAsset( AssetImportContext ctx ) { TextAsset subAsset = new TextAsset( File.ReadAllText( ctx.assetPath ) ); ctx.AddObjectToAsset( &amp;#34;text&amp;#34;, subAsset ); ctx.SetMainObject( subAsset ); } } Ref Scripted Importers [Unity] 资源工作流程 - ScriptedImporter</description></item><item><title>Unity - Package Manager</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-manager/</link><pubDate>Sat, 22 Apr 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-manager/</guid><description>Package Samples 對應有些模組的操作比較複雜繁瑣，有時需要有一些 Sample 做參考。官方 Package Manager 有個 &amp;ldquo;半套&amp;rdquo; Sample 工作流，讓人不是很舒服。
官方文件
Sample 資料夾後面加了波浪號 (~) 告訴 Unity 忽略 Samples~ 文件夾中的內容，此類文件夾不使用.meta文件進行跟踪。忽略 Samples~ 對 Package 使用者是好的，畢竟不是每個人都需要。
但對 Package 開發者，畢竟 Samples 也是要進版控的，而這樣改名的作法會徒增一些重命名的提交也有點煩躁(除非在修改 Sample 的過程中完全不提交)。原先想說寫個 Samples ↔ Samples~ 切換的腳本就好，會一直有 meta 檔的警告(刪掉/改名都還是在)。
官方作法 論壇中的某篇討論才記載他們的做法(倒是加到文件中阿&amp;hellip;)
在內部確實使用了名為 Samples 的文件夾 (沒有 Samples~ ) 在推送新包版本之前通過腳本對其進行重命名(透過 CI ) OpenUPM 的作者也是使用類似的工作流，總之筆者也調整為上述的方式。
透過 GitHub Actions Workflow 調整目錄名 筆者不熟 GitHub Actions/ YAML/ 文件操作，但這種初階的操作就交由 chatgpt 代勞，幫我省去不少實驗成本。這裡的操作只是堪用，應該有更好的方式。
以下是筆者要求的條件
想透過 GitHub Actions 中的 workflow 完成 如果 forPackage 分支已存在則將其刪除 從 main 建立新的 forPackage 分支 Assets/Modules 的所有子目錄(同時有 &amp;ldquo;package.</description></item><item><title>Unity - Package - HybridCLR</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-hybridclr/</link><pubDate>Tue, 11 Apr 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-hybridclr/</guid><description>以下將著重在&amp;quot;程式碼&amp;quot;的熱更。
前述 HybridCLR 的 github 星數已經超過 ILRuntime 了，且中國那邊的主流框架幾乎都對其加入支援，是備受期待的存在。
其極大簡化過往麻煩且效率不彰的熱更流程。現在主流的方式有兩個：Lua 和 ILRuntime。但主流並不一定是好用的，也有可能只是迫不得已。主流兩者在筆者看來最難受的事是「侵入性」極強，有時為了熱更必須將業務邏輯移到 Lua 和 ILRuntime，搞得綁手綁腳。大家也都抱怨很久了，但也沒有其他可靠方案，直到 HybridCLR 出現。
其最讓人驚豔的地方在於，過往的開發流幾乎不用更動(不用寫 Lua 到處黏來黏去，只要寫好 C# 即可)，僅在打包時調整一下工作流即可。
此外 Unity 引擎開發團隊宣布，他們已開始將 Unity 引擎運行時從 Mono 遷移到 .NET CoreCLR。他們還會提供融合 JIT 和 AOT 的解決方案，Unity 團隊計劃在 2024 年發布新編輯器。(雖然常跳票就是了)，因此筆者相信 類 HybridCLR 的作法在未來會成為主流做法，姑且先樂觀其成。
focus-creative-games/hybridclr focus-creative-games/hybridclr_trial focus-creative-games/hybridclr_unity 快速上手 3.0 版本後流程優化得更順暢了，照著 文件 可以很快地感受到
實測 為此筆者以一個小專案測試
App Module 主模組，非熱更模組(包含AOT) Navigation Module 熱更模組(應用程式是可以接受動態導航的) RockPaperScissors Module 熱更模組(一個簡單的猜拳應用) 模組之間的關係
App 啟動後會去下載 Navigation Module (一開始是沒有在本地) Navigation 有一組 UI 與下載 RockPaperScissors Module(也沒有在本地) 的邏輯段 測試結果 PC 與 Android 都可以完成動態加載邏輯與資源，且完全使用 C# 並以極低侵入完成熱更。在實作過程中反覆查了多次文件，確實需要一點成本來理解，但工作流(一次性)成型後便很舒服了。</description></item><item><title>Unity - Basic - DontDestroyOnLoad</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-dontdestroyonload/</link><pubDate>Mon, 20 Mar 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-dontdestroyonload/</guid><description>用例 被標記為 DontDestroyOnLoad 的物件場景更改時不會被破壞。
全域管理器：因為整個遊戲期間一直存在。例如，音效管理器、遊戲設定管理器或玩家數據管理器等物件可以在場景切換時保留，以確保它們的功能和數據在各個場景中持續存在。 持久性數據：如果你有需要在多個場景中共享的持久性數據，可以將存儲這些數據的物件標記為 DontDestroyOnLoad。例如，玩家的遊戲進度或全域的配置設置等數據可以在場景切換時保留，以便在不同場景中訪問和更新。 UI 元素：某些UI元素，如遊戲狀態面板、計時器或得分顯示，可能需要在多個場景中保留。通過將這些UI元素物件標記為 DontDestroyOnLoad，可以確保它們在場景切換時不會被銷毀，以便在不同場景中持續顯示和更新。 問題 記憶體管理問題：使用 DontDestroyOnLoad 將遊戲物件保留在多個場景中可能會導致記憶體洩漏。如果你的遊戲物件不再需要，但沒有被正確銷毀，它們將繼續存在於記憶體中，佔用系統資源，可能導致性能下降。 場景管理問題：DontDestroyOnLoad 會打破場景之間的清晰界限。場景是 Unity 中組織和管理遊戲邏輯的基本單位，每個場景都應該是相對獨立的。通過在多個場景之間保持物件，會增加場景之間的耦合性，導致代碼難以維護和測試。 Ref Object.DontDestroyOnLoad</description></item><item><title>Unity - WorkFlow - Build &amp; Publish</title><link>https://HoshikawaRyuukou.github.io/posts/unity-workflow-build-publish/</link><pubDate>Mon, 27 Feb 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-workflow-build-publish/</guid><description>Build repositories.cfg could not be loaded. Unable to find player assembly: XXXX\Temp\StagingArea\Data\Managed\UnityEngine.TestRunner.dll Device Quickly preview your game on Android device | Unity tutorial Publish Privacy policy for your game? No problem! (generate and publish) Publish your UNITY game on Google Play Store - 2023 guide</description></item><item><title>Misc - Sites(待讀)</title><link>https://HoshikawaRyuukou.github.io/posts/misc-sites%E5%BE%85%E8%AE%80/</link><pubDate>Mon, 20 Feb 2023 21:12:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/misc-sites%E5%BE%85%E8%AE%80/</guid><description>ios 【Unity】iOSネイティブプラグイン開発を完全に理解する - サンプルコードをSwiftだけで完結出来るように置き換える 【Unity】iOSネイティブプラグイン開発を完全に理解する Swift だけで Unity の iOS の Native Plugin を作る ads 介接Unity Ads Modularization The “Real” Modularization in Android</description></item><item><title>Unity - Basic - Sprite</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-sprite/</link><pubDate>Mon, 20 Feb 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-sprite/</guid><description>Sprite 【2Dゲームで必須】UnityのSprite（スプライト）の単位をわかりやすく解説 【間違えやすい】Unityの正しい画像サイズとは Atlas 【Unity】SpriteをパックするSpriteAtlasの使い方 目的 減少DrawCall 圖集將圖片打包為2的冪次方的素材大小，可以提升性能 減小包體大小 注意 以 Sprite Atlas V1 - Always Enabled 啟用圖集時 Edit Mode : reference the packed Textures Play Mode : reference the original unpacked Textures</description></item><item><title>Unity - Sites</title><link>https://HoshikawaRyuukou.github.io/posts/unity-sites/</link><pubDate>Mon, 20 Feb 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-sites/</guid><description>Blog 游戏石匠Super L&amp;rsquo;s Blog コガネブログ 渋谷ほととぎす通信 きゅぶろぐ LIGHT11 Raspberlyのブログ PG日誌 やらなイカ？ Game Dev Beginner - Everyone Can Make Games LianBai (:3[kanのメモ帳] Unityゲーム開発者ギルド 老刘@开发笔记 はなちるのマイノート くものす Engineering Blog REALITY｜note Learning Unity Learning Materials Channel Unity Unity Japan Code Monkey M Studio Coco Code</description></item><item><title>Unity - 基礎</title><link>https://HoshikawaRyuukou.github.io/posts/unity-%E5%9F%BA%E7%A4%8E/</link><pubDate>Mon, 20 Feb 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-%E5%9F%BA%E7%A4%8E/</guid><description>Analysis Unity Optimize Your Game Using Profiler Unity 手機遊戲最佳化雜談– 內建Profiling Animation Introduction to 3D Animation Systems Audio Unity Audio Clip Import Settings For The Best Performance Audio tutorial for Unity: the Audio Mixer The right way to make a volume slider in Unity Build repositories.cfg could not be loaded. unity Camera Understanding Orthographic Size 探寻 Unity Camera 属性之 Clear Flags Unityの画面のアスペクト比と解像度を自動変換　全スマホ・複数解像度に対応させる Canvas Designing UI for Multiple Resolutions Unity Canvas Scaler 组件的使用 Unity分辨率适配方案设置 Editor 在unity编辑器不同位置添加菜单 SerializeReferenceをつけている型をリネーム・削除する時の注意点 What are EditorBuildSettings config objects used for or how can I use them?</description></item></channel></rss>