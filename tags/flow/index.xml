<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Flow on 識之箱庭</title><link>https://HoshikawaRyuukou.github.io/tags/flow/</link><description>Recent content in Flow on 識之箱庭</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>HoshikawaRyuukou</copyright><lastBuildDate>Wed, 16 Nov 2022 21:11:00 +0000</lastBuildDate><atom:link href="https://HoshikawaRyuukou.github.io/tags/flow/index.xml" rel="self" type="application/rss+xml"/><item><title>FlowControl</title><link>https://HoshikawaRyuukou.github.io/posts/flowcontrol/</link><pubDate>Wed, 16 Nov 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/flowcontrol/</guid><description>以下 Feature 指的是一個功能獨立的模塊 (畫面 ⇄ 業務)，Feature A 將簡稱 A。
問題 應用程式中有一個由 A 到 B 的導航，那這個導航是誰的責任? 以下討論三種狀況。
A 直接依賴 B 由 A 將 B 實例化並操作他，簡單粗暴。但出現強耦合，強耦合不是問題但他破壞了 A 的獨立性。當流程發生變化時，可能需要到各個 Feature 去修改。
Feature A -&amp;gt; new Feature B Feature A -&amp;gt; Open Feature B A 引入導航器使其能導航到 B 這作法將導航操作收斂到導航器中，但 A 仍然隱含的知道 B，這同樣破壞了 A 的獨立性。
Feature A -&amp;gt; INavigator.Route(View.FeatureB) // Enum or Feature A -&amp;gt; INavigator.Route(&amp;#34;FeatureB&amp;#34;) // 魔術字串 or Feature A -&amp;gt; INavigator.RouteFeatureB() 導航是獨立操作 說到底 Feature 應該知道自己是能夠被導航或是能導航到哪嗎?</description></item></channel></rss>