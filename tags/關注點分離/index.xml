<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>關注點分離 on 識之箱庭</title><link>https://HoshikawaRyuukou.github.io/tags/%E9%97%9C%E6%B3%A8%E9%BB%9E%E5%88%86%E9%9B%A2/</link><description>Recent content in 關注點分離 on 識之箱庭</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>HoshikawaRyuukou</copyright><lastBuildDate>Sat, 10 Dec 2022 20:05:00 +0000</lastBuildDate><atom:link href="https://HoshikawaRyuukou.github.io/tags/%E9%97%9C%E6%B3%A8%E9%BB%9E%E5%88%86%E9%9B%A2/index.xml" rel="self" type="application/rss+xml"/><item><title>邏輯與畫面分離 - MVP 與 MVVM</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%82%8F%E8%BC%AF%E8%88%87%E7%95%AB%E9%9D%A2%E5%88%86%E9%9B%A2-mvp-%E8%88%87-mvvm/</link><pubDate>Sat, 10 Dec 2022 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%82%8F%E8%BC%AF%E8%88%87%E7%95%AB%E9%9D%A2%E5%88%86%E9%9B%A2-mvp-%E8%88%87-mvvm/</guid><description>導覽 網上已經有很多不錯的文章，再寫一份類似的整理文章意義也不大，對 MVP / MVVM 感到陌生，不妨閱讀以下連結，會幫助你理解 MV系列 的發展。因此這裡提出一些使用場合與風險考量。
界面之下：还原真实的MV*模式 正确认识 MVC/MVP/MVVM 站在思想层面看MVX架构 MVP Pattern: Part 2 Supervising Controller Part 2 — Converting Presenters into ViewModels 前述 眾所周知畫面(View)的變更需求是很高的，因此會希望邏輯與畫面分離，以實現關注點分離（separation of concerns）。
邏輯專注於業務處理。 畫面專注於使用者互動。 但分開的事務之間仍需溝通，因此需要有單位出來做協調，MVP 與 MVVM 兩者以不同方式來實作。
MVP - Presenter MVVM - ViewModel 題外話 筆者不使用&amp;quot;優點/缺點&amp;quot;而用&amp;quot;場合/風險&amp;quot;，因為優點/缺點是要看上下文的。 MVP ( Model-View-Presnter) 中介者模式( Mediator Pattern )，Presenter 協調 Model 與 View，使邏輯與畫面解耦。 Presnter 依照依賴倒置原則開出 IView 介面讓 View 來實作，以達到無痛切換 View。而 View 設計成 Passive View 完全被 Presnter 操控。 場合 筆者開發預設使用 MVP，因為其設計風格是命令式的，編寫上較為直覺，且不需額外的擴充功能便可實踐(只需依賴倒置)，實作成本低。 當上下文是純粹輸出時，比較沒有狀態的概念時(數據不會被二次參考)。 Ex: 戰鬥傷害數值呈現，僅在畫面中閃過即結束。 風險 狀態很容易最終分散在 Presenter 和 View 之中，畢竟很直覺地把數據倒給了 View 。如果上下文中&amp;quot;狀態&amp;ldquo;很重要的話，可以評估採用 MVVM 。</description></item></channel></rss>