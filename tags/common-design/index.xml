<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Common Design on 識之箱庭</title><link>https://HoshikawaRyuukou.github.io/tags/common-design/</link><description>Recent content in Common Design on 識之箱庭</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>HoshikawaRyuukou</copyright><lastBuildDate>Fri, 19 Jan 2024 21:05:00 +0000</lastBuildDate><atom:link href="https://HoshikawaRyuukou.github.io/tags/common-design/index.xml" rel="self" type="application/rss+xml"/><item><title>通用設計 - Architecture - VIPER</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-architecture-viper/</link><pubDate>Fri, 19 Jan 2024 21:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-architecture-viper/</guid><description>簡述 VIPER (View-Interactor-Presenter-Entity-Router)
iOS VIPER架構實踐(一)：從MVC到MVVM到VIPER VIPER，更清晰的架构，解决复用和测试问题的利器系列1：VIPER架构演进史 有很多種實作流派，下圖是我比較偏好的模式呈現
VIPER 借鏡了 CA (Clean Architecture) 的思想為 MVC 提供一個新的設計方案
Entity 對應原本的 Model Controller 責任過重 -&amp;gt; 將業務邏輯移至 Interactor 並提高重用性 Controllers 之間耦合 -&amp;gt; 將導航邏輯移至 Router Presenter 作為 Binder 將 View / Interactor / Router 整合 啟發 VIPER 是筆者學習架構路上很重要的一個過渡，有以下兩點的思想轉變
顆粒度更細的單一職責 Interactor 封裝業務的概念在純 MVX 中是無法直接體會到，因此對之後學習 CA 時起了很大的緩衝，不然對於 Usecase 的設計應該會很不適應。
重視 Navigation 在學習 CA 中始終沒題到 feature/componet module 之間是如何互動的，也是在回頭複習 VIPER 時才重新意識到 Router 的重要性。當沒有特別規劃 Navigation 時很容易會造成 module 之間的耦合。</description></item><item><title>通用設計 - Sites</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-sites/</link><pubDate>Mon, 02 Jan 2023 21:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-sites/</guid><description>Blogs Khalil Stemmler | Become a confident crafter. Learn to write testable, scalable TypeScript. Entropy Wins - A blog on Software Architecture, Design and Craftsmanship jyt0532&amp;rsquo;s Blog Tomas Tulka&amp;rsquo;s Blog CodeOpinion Advice for junior developers Guide DevIQ Others The Last Responsible Moment DRY is about Knowledge</description></item><item><title>通用設計 - Architecture - Navigation</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-architecture-navigation/</link><pubDate>Wed, 16 Nov 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-architecture-navigation/</guid><description>以下 Feature 指的是一個功能獨立的模組，Feature A 將簡稱 A。
問題 應用程式中有一個由 A 到 B 的導航，那這個導航是誰的責任?
以下先討論 2 種狀況。
A 直接依賴 B 簡單粗暴的強耦合破壞了 A 的獨立性。當流程發生變化時，可能需要到各個 Feature 去修改。
Feature A -&amp;gt; Feature B A 引入導航器間接依賴 B 這作法將導航操作收斂到某個類中，但 A 仍然隱含的知道 B，這同樣破壞了 A 的獨立性。
Feature A -&amp;gt; INavigator.Route(View.FeatureB) // Enum or Feature A -&amp;gt; INavigator.Route(&amp;#34;FeatureB&amp;#34;) // 魔術字串 or Feature A -&amp;gt; INavigator.RouteFeatureB() 重新思考導航這件事
Feature 應該知道自己是能夠 被導航 或是 能導航到哪 嗎? 到底 A 能導航到 B 這件事是誰決定的? 應該隱約地感覺到了吧，導航並不屬於 A 也不屬於 B，導航是一個獨立操作，需要一個額外的單位來負責。此外這個單位多是屬於 App 級別的(因為該層級有對其他模組的正當訪問性，畢竟是負責做統合的)。</description></item></channel></rss>