<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Common Design on 識之箱庭</title><link>https://HoshikawaRyuukou.github.io/tags/common-design/</link><description>Recent content in Common Design on 識之箱庭</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>HoshikawaRyuukou</copyright><lastBuildDate>Fri, 05 May 2023 20:05:00 +0000</lastBuildDate><atom:link href="https://HoshikawaRyuukou.github.io/tags/common-design/index.xml" rel="self" type="application/rss+xml"/><item><title>通用設計 - Inversion of Control (IoC) 與 Dependency Injection (DI)</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-inversion-of-control-ioc-%E8%88%87-dependency-injection-di/</link><pubDate>Fri, 05 May 2023 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-inversion-of-control-ioc-%E8%88%87-dependency-injection-di/</guid><description>控制反轉 Inversion of Control，以下皆簡稱 IoC。 依賴注入 Dependency Injection，以下皆簡稱 DI。
之前還有提到過 依賴倒置原則 (Dependency Inversion Principle，DIP)，而筆者理解到這三者的關係是
DI 是 IoC 的一種實踐方式 DIP 則能為 IoC 提高依賴穩定性 為什麼需要 資源複用: 避免創建重複對象，有些對象只需要實例化一個就夠了，不需要使用方都自己 new 一個新的。
集中配置依賴項: 依賴需求方操作其依賴項來完成任務才是他主要的責任，如果還要處理依賴項的實例化(更不用說依賴項的依賴項要怎麼處理)，責任就模糊了，因此將依賴項的創建和配置的控制權交給 IoC Container。
基本操作 通常而 IoC Container 包含以下操作：
Register：註冊類型和依賴關係 Resolve：創建並註入依賴關係 Dispose：管理生命週期 而實踐方式常見的有兩種
Service Locator 服務定位器 可以簡單理解為直接使用容器本身，因此依賴需求方在需要依賴的地方可以使用 Locator.Resolve 來取得依賴，但這樣有幾個問題
Resolve 可以填什麼 ? 是不是有註冊的項目都能任意取得阿 ? 這也是有些人認為服務定位器有反模式味道的點 DI 依賴注入 依賴注入則是間接地使用容器，常透過三種方式注入依賴項，
建構子(推薦) 屬性 方法 權限相對清晰(建構子注入)，能用依賴項的都在建構子給你了，不過你要額外new 其他東西也是沒人攔得住。此外依賴需求方是不知道容器的存在(理想狀態，但有時會需要一些注入標記)</description></item><item><title>通用設計 - Guard Clauses</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-guard-clauses/</link><pubDate>Tue, 10 Jan 2023 21:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-guard-clauses/</guid><description>目的 符合 Fail Fast 的原則，驗證條件並在不滿足條件時立即停止執行。 增加可讀性(更扁平)，減少了巢狀判斷。 例子請參考 Guard Clause Extra - Guard Class 將通用的保護子句封裝在一個專門的類是一種很好的做法，可重用邏輯並編寫更具可讀性的保護子句。
可參考這個庫 GuardClauses Extra - Value Object Stop using trivial Guard Clauses! Try this instead
文章作者避免瑣碎 Guard 的方式，是使用 Value Object，來避免域接受到無效參數。這個作法在筆者看來才是真正意義上的 Fail Fast。(YT評論區也建議閱讀，有許多不錯的討論)
但不可否認的 Guard Clause 作法在大多情況下是有益的。
Ref Guard Clause Implementation Patterns: Guard Clause GuardClauses Stop using trivial Guard Clauses! Try this instead</description></item><item><title>通用設計 - 設計原則</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87/</link><pubDate>Mon, 02 Jan 2023 21:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87/</guid><description>Library DevIQ Experiences Advice for junior developers Other The Last Responsible Moment DRY is about Knowledge</description></item><item><title>通用設計 - Data Transfer Object (DTO)</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-data-transfer-object-dto/</link><pubDate>Sun, 11 Dec 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-data-transfer-object-dto/</guid><description>什麼是 DTO？ Data Transfer Object (數據傳輸對象) 是定義如何在應用程序之間發送數據的對象。它僅用於發送和接收數據，本身不包含任何邏輯。
為什麼使用 DTO？ 輕鬆收發 在沒有任何邏輯的基礎上，可以僅使用序列化與反序列化就保證對象的完整性和可傳遞性。
避免過度暴露訊息 對分層或模組來說，彼此間應盡量降低耦合。下圖以公園廁所報修為案例。
這個資料流由鄉公所傳到基層人員手上，中間經過兩個邊界
鄉公所 | 工程公司 =&amp;gt; DTO (公文) 工程公司 | 基層人員 =&amp;gt; DTO (簡訊) 每個單位的關注點不同，在意的資料也會不同，DTO 做為邊界兩方做最小程度的媒介，隱藏的不該被關注(敏感)的事
印章對工程公司並不是必要資訊 詳細的時間格式是對基層人員並不是必要資訊 在實作上常被用於轉換 DomainModol -&amp;gt; DomainDto
注意事項 類別數量增加，請自行評估使用情形
Ref Cutting Edge - Pros and Cons of Data Transfer Objects The DTO (Data Transfer Object) Data Transfer Objects Clean Architecture : why not using the entity as request model of the use case (interactor) Difference between Entity and DTO</description></item><item><title>通用設計 - Pattern - MVP</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-pattern-mvp/</link><pubDate>Sat, 10 Dec 2022 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-pattern-mvp/</guid><description>前述 關注點分離（Separation of Concerns，SoC）: 在軟體開發中，一個模組或組件應該專注於解決特定的問題，而不是同時處理多個功能。每個組件都有自己的職責範圍，並且與其他組件盡可能解耦合。
而 MVC / MVP / MVVM 是關注點分離於前端的經典應用，網上已經有很多不錯的文章，再寫一份類似的整理文章意義也不大，對此感到陌生，不妨閱讀以下連結，會幫助你理解 MV系列的發展。
界面之下：还原真实的MV*模式 正确认识 MVC/MVP/MVVM 站在思想层面看MVX架构 MVP Pattern: Part 2 Supervising Controller Part 2 — Converting Presenters into ViewModels 以下則對筆者實作中比較常用的 MVP 多做一些討論
關注點(責任) 在 MVP 的構成下分成三個部分
Model: 應用程式的核心邏輯。 View: 應用程式的使用者介面，負責呈現數據和接收使用者的輸入。 Presenter: View 和 Model 之間的中介。 Passive View 這是 MVP 的一種實作風格，也是筆者主要使用的風格。
Presenter 對 View 有完全控制權 View 提供方法與事件給 Presenter 使用 View 對 Presenter 一無所知 以猜拳遊戲的 View 為例
public class View : MonoBehaviour { [SerializeField] private Text messageText; [SerializeField] private Button[] playerChoices; [SerializeField] private Button nextButton; private readonly Subject&amp;lt;Choice&amp;gt; playerChoiceSelected = new Subject&amp;lt;Choice&amp;gt;(); private readonly CompositeDisposable disposables = new CompositeDisposable(); public IObservable&amp;lt;Choice&amp;gt; PlayerChoiceSelected =&amp;gt; playerChoiceSelected; public IObservable&amp;lt;Unit&amp;gt; PlayerNextRequested =&amp;gt; nextButton.</description></item><item><title>通用設計 - 邏輯與畫面分離 MVP 與 MVVM</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-%E9%82%8F%E8%BC%AF%E8%88%87%E7%95%AB%E9%9D%A2%E5%88%86%E9%9B%A2-mvp-%E8%88%87-mvvm/</link><pubDate>Sat, 10 Dec 2022 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-%E9%82%8F%E8%BC%AF%E8%88%87%E7%95%AB%E9%9D%A2%E5%88%86%E9%9B%A2-mvp-%E8%88%87-mvvm/</guid><description>導覽 網上已經有很多不錯的文章，再寫一份類似的整理文章意義也不大，對 MVP / MVVM 感到陌生，不妨閱讀以下連結，會幫助你理解 MV系列 的發展。因此這裡只是提出一些重點觀念與實作考量。
界面之下：还原真实的MV*模式 正确认识 MVC/MVP/MVVM 站在思想层面看MVX架构 MVP Pattern: Part 2 Supervising Controller Part 2 — Converting Presenters into ViewModels 前述 眾所周知畫面(View)的變更需求是很高的，因此會希望業務與畫面分離，以實現關注點分離（Separation of Concerns，SoC）。但分開的事務之間仍需溝通，因此需要有單位出來做協調，MVP 與 MVVM 兩者以不同方式來實作。
MVP: Model-View-Presenter MVVM: Model-View-ViewModel *Model 指的是業務邏輯可能是 DomainModel/ Usecase/ Service 等，依系統的規模架構而定。
以下是筆者常使用 3 種類型的依賴關係 MVP (DIP) Presenter 基於 依賴倒置原則 定義 IView 介面來讓 View 實作。 Presenter 可適用於不同的 View(IView)。 View 被綁訂於定義出 IView 的 Presenter。 View 一般設計成 Passive View。 MVP Presenter 基於 轉接器模式(Adapter Pattern) 作為膠水代碼以協調 Model 與 View。 Presenter 是配合 View 的那一方，畢竟在前端 View 組件是有一定的重用考量(也就是 View 不能改)。 基於實作上的經驗，View 更換的次數沒有想像中的高。所以這個方案是筆者比較常用的(實作最快)，當真的有變化時在往 MVP (DIP) 或 MVVM 調整即可。 MVVM 與上述 MVPs 最大的不同是 ViewModel 對 View 一無所知，僅是公開狀態/數據流供外部觀察，完全隔離了畫面，純粹管理狀態。 ViewModel 基於 觀察者模式(Observer Pattern)，所以一個 ViewModel 可被多個 View 觀察。 View 只需要訂閱該狀態並反映它。Data Binding 可簡化綁定動作。 筆者覺得 ViewModel 的難點在於其大小，太大很能管控，太小又會導致狀態很分散。十分依賴規劃者的經驗。</description></item><item><title>通用設計 - Navigation</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-navigation/</link><pubDate>Wed, 16 Nov 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-navigation/</guid><description>以下 Feature 指的是一個功能獨立的模組，Feature A 將簡稱 A。
問題 應用程式中有一個由 A 到 B 的導航，那這個導航是誰的責任?
以下先討論 2 種狀況。
A 直接依賴 B 簡單粗暴的強耦合破壞了 A 的獨立性。當流程發生變化時，可能需要到各個 Feature 去修改。
Feature A -&amp;gt; Feature B A 引入導航器間接依賴 B 這作法將導航操作收斂到某個類中，但 A 仍然隱含的知道 B，這同樣破壞了 A 的獨立性。
Feature A -&amp;gt; INavigator.Route(View.FeatureB) // Enum or Feature A -&amp;gt; INavigator.Route(&amp;#34;FeatureB&amp;#34;) // 魔術字串 or Feature A -&amp;gt; INavigator.RouteFeatureB() 重新思考導航這件事
Feature 應該知道自己是能夠 被導航 或是 能導航到哪 嗎? 到底 A 能導航到 B 這件事是誰決定的? 應該隱約地感覺到了吧，導航並不屬於 A 也不屬於 B，導航是一個獨立操作，需要一個額外的單位來負責。此外這個單位多是屬於 App 級別的(因為該層級有對其他模組的正當訪問性，畢竟是負責做統合的)。</description></item><item><title>通用設計 - Dependency Inversion Principle (DIP)</title><link>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-dependency-inversion-principle-dip/</link><pubDate>Tue, 15 Nov 2022 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/%E9%80%9A%E7%94%A8%E8%A8%AD%E8%A8%88-dependency-inversion-principle-dip/</guid><description>依賴倒置原則 Dependency Inversion Principle，以下皆簡稱 DIP。
為什麼需要 先來看定義
高層次的模塊不應該依賴於低層次的模塊，兩者都應該依賴於抽象接口 抽象接口不應該依賴於具體實現。而具體實現則應該依賴於抽象接口 文謅謅的，但重點似乎是抽象。不如直接看個狀況劇:
有一個 Project A 需要使用播廣告的功能。分別採 2 個做法
直接依賴 直覺的做法。Project A 直接依賴於廣告模組(UnityAds)，這裡模組 Project A 被迫去了解 UnityAds 的實作細節(怎麼初始化/下載廣告/播廣告)。
目前沒甚麼問題，運作得很好&amp;hellip; 但很快問題就來了。UnityAds 因為某些原因不能用了! (假設後臺被打了什麼的)。於是找了另一個廣告模組(AdMob)，想要如法炮製，但有幾點可能會不好受。
要改的地方很分散 (廣告被 Project A 多處使用) Project A 需要處理不同的 API格式 (了解細節，單例、Callback、事件&amp;hellip;) 導致原先依賴 UnityAds 的模組需要重新編譯 (造成浪費時間) 原因是直接依賴外部模組導致的，相對於你的系統 UnityAds 是個外人，是不穩定的，去依賴一個不穩定的東西，也會導致自己變得不穩定。
依賴倒置 仔細想一下，Project A 直接依賴 UnityAds 是必要的嗎? 需求是播 UnityAds 的廣告? 還是播廣告? 為了實現穩定廣告服務的依賴源，我們將其抽象化
public interface IAdService { void Initialize(); void Load(); void Show(); } 但 UnityAds 與 AdMob 又不能直接實作這個介面怎麼辦，可以用配接器模式(Adapter Pattern)寫個轉接頭，想辦法讓外部細節符合 IAdService 的需求。現在需要廣告服務的部分均透過 IAdService來操作，不需再知道外部廣告模組的細節。</description></item></channel></rss>