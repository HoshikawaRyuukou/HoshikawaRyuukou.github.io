---
title: "通用設計 - Inversion of Control (IoC)"
date: 2022-12-15 20:05:00
draft: true

tags: ["Common Design"]
---

IoC 的抽象概念是「依賴關係的轉移」，像是「高層模組不應該依賴低層模組，而是模組都必須依賴於抽象」是 IoC 的一種表現，「實現必須依賴抽象，而不是抽象依賴實現」也是 IoC 的一種表現，「應用程式不應依賴於容器，而是容器服務於應用程式」也是 IoC 的一種表現。

程式的業務邏輯部份應是可以重用的，不應受到所使用框架或容器的影響，因為可能轉移整個業務邏輯至其它的框架或容器，如果業務邏輯過於依賴容器，則轉移至其它的框架或容器時，就會發生困難。

IoC 在容器的角度，可以用這麼一句好萊塢名言來代表："Don't call me, I'll call you." 以程式的術語來說的話，就是「不要向容器要求您所需要的（物件）資源，容器會自動將這些物件給您！」。IoC 要求的是容器不侵入應用程式本身，應用程式本身提供好介面，容器可以透過這些介面將所需的資源注至至程式中，應用程式不向容器主動要求資源，故而不會依賴 於容器的元件，應用程式本身不會意識到正被容器使用，可以隨時從容器中脫離轉移而不用作任何的修改，而這個特性正是一些業務邏輯中間件最需要的。

這是我在學習架構時的第一道關卡，也是我覺得受用最大的。

- 控制反轉 (Inversion of Control，IoC）
- 依賴注入 (Dependency Injection，DI）
- 依賴倒置原則 (Dependency Inversion Principle，DIP）

譯名可能有很多種，上面是我習慣叫的，因為 Inversion 有兩個，所以一個錯開稱呼比較不會記錯，以下都使用縮寫。

我理解到這三者的關係是
- DI 是 IoC 的一種實踐方式
- DIP 則能為 IoC 提高依賴穩定性

----------------------

為什麼要 IoC ?

- 資源復用: 
避免創建重複對象，有些組件只需要實例化一個就夠了，不需要使用方都自己 new 一個新的。

- 集中配置依賴項:
組件操作依賴項來完成任務才是他主要的責任，如果還要處理依賴項的實例化(更不用說依賴項的依賴項要怎麼處理)，責任就模糊了，
因此將依賴項的創建和配置的控制權交給 IoC Container，組件專心操作依賴項就好

而 IoC Container 包含以下部分：
Register：註冊類型和依賴關係
Resolve：創建並註入依賴關係
Dispose：管理生命週期

IoC Container 有兩種使用方式

- Service Locator 服務定位器
可以簡單理解為直接使用容器本身，因此組件在需要依賴的地方可以使用 Locator.Resolve<????> 來取得依賴
但這樣有一個問題是 Resolve<???> 我可以填什麼 ?
是不是有註冊的我都能任意取得阿?
沒錯，組件的權限不明確，這也是有些人認為服務定位器有反模式味道的點

- DI 依賴注入
依賴注入則是間接地使用容器，依賴項透過 建構子(推薦)、屬性和方法注入
權限相對清晰(建構子注入)，組件能用的都在建構子給你了，當然你要額外new其他東西也是沒人攔得住

----------------------

