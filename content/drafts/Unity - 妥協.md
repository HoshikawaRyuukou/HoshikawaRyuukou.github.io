---
title: "Unity - 妥協"
date: 2023-03-02 21:11:00
draft: true

tags: ["Unity"]
---

畫面轉換必須是「共通功能」
如果在發布時要建立100個以上的畫面，一個一個地建立將永遠無法結束
1.多人同時開發
2.直接轉換
3.畫面製作的共通化
建議每個畫面都建立一個Prefab，並且讓多人同時開發多個畫面

直接轉換指的是，可以直接從任何畫面轉換到任何其他畫面。
更具體地說，例如任務畫面不需要經過主畫面才能轉換，這樣的限制是不被允許的。
換句話說，任務畫面可以從主畫面或強化畫面任意一個地方轉換。

在開發中，最耗時的事情是「猶豫不決」。
建議制定以下規則，並可進行擴展，讓所有畫面都具備以下功能：

畫面顯示前的處理
畫面顯示
畫面隱藏
畫面隱藏後的處理



-----
即使是遊戲，分離「領域邏輯和演示」也是一個普遍且值得做的事情。抽象數據和視圖的邊界必須疏離耦合，否則將會遇到嚴重問題。由於「角色數據」與「要應用於屏幕上的對象」之間的關係不是一對一的，而且還有一些情況是尚未顯示在屏幕上，但需要參考數據，這就是這種情況的原因。

總之，MVC所說的「Model」不是所有狀態轉換，而是「應用程序特定狀態」。

然而，在遊戲中使用強大的框架和基於預設的設計模式只會變成一種麻煩。

首先，構建MVP的結構，使M和V的世界完全分開。M部分可以創建基於DDD分層體系結構等的責任分配。 V組件本身可以隱藏細節並形成黑盒子，例如父子關係或過於細節的控制，因為這些內容可以從外部隱藏起來。

Presenter/Controller則連接這些世界。只要以此為基礎，在適當的項目中改變分類方式就足夠了。

多層抽象層(乾淨的)架構的思想只需應用於抽象數據交換部分即可。

派生自MVC的「領域和演示的分離」可應用於整個系統。

外部看來，UI = f(state)的觀念隱藏了視圖狀態轉換，這也是非常有用的。

但是，自動映射到視圖的方法可能不太靈活，並且可能會影響生產力和可維護性。

以上是個人的看法。

https://hadashia.hatenablog.com/entry/2020/12/22/162525


View = f(state)

在理解 View 是怎麼變化的時候，能夠先決定並先控制好 state，render 過程中也不會改變 state，剩下的事情就輕鬆簡單了

畢竟，視圖只是核心模型的投影，而這只是為了描述應用程序的核心狀態。它之外的任何東西都應該由視圖模型或視圖層處理
